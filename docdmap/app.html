<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„ÉÜ„Çπ„Éà‰ªïÊßòÊõ∏„Ç®„Éá„Ç£„Çø„Éº</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab;
        }

        #canvas.grabbing {
            cursor: grabbing;
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .node {
            position: absolute;
            background: white;
            border: 3px solid #667eea;
            border-radius: 12px;
            padding: 15px;
            min-width: 200px;
            max-width: 800px;
            min-height: 100px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: move;
            z-index: 2;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.3s, background-color 0.3s;
            resize: none;
            display: flex;
            flex-direction: column;
        }

        .node:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .node.dragging {
            opacity: 0.8;
            z-index: 1000;
        }

        .node.selected {
            border-color: #ff6b6b;
            box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.3);
        }

        .node.resizing {
            transition: none;
        }

        .node.resizing:hover {
            transform: none;
        }

        .view-mode {
            flex: 1;
            overflow: auto;
        }

        /* „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´ */
        .resize-handle {
            position: absolute;
            background: transparent;
            z-index: 11;
        }

        .resize-handle.top {
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
        }

        .resize-handle.bottom {
            bottom: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
        }

        .resize-handle.left {
            left: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
        }

        .resize-handle.right {
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
        }

        .resize-handle:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        /* „Ç≥„Éç„ÇØ„Çø„Éº */
        .connector {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #667eea;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s;
            opacity: 0;
        }

        .node:hover .connector {
            opacity: 1;
        }

        .connector:hover {
            width: 16px;
            height: 16px;
            background: #5568d3;
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.6);
        }

        .connector.active {
            opacity: 1;
            background: #ff6b6b;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3);
            }
        }

        .connector.top {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connector.bottom {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connector.left {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connector.right {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connector.top:hover,
        .connector.top.active {
            transform: translateX(-50%) scale(1.3);
        }

        .connector.bottom:hover,
        .connector.bottom.active {
            transform: translateX(-50%) scale(1.3);
        }

        .connector.left:hover,
        .connector.left.active {
            transform: translateY(-50%) scale(1.3);
        }

        .connector.right:hover,
        .connector.right.active {
            transform: translateY(-50%) scale(1.3);
        }

        /* „Çπ„ÉÜ„Éº„Çø„Çπ„Å´„Çà„Çã„Éé„Éº„Éâ„Çπ„Çø„Ç§„É´Â§âÊõ¥ */
        .node.status-OK {
            border-color: #2ecc71;
            border-width: 3px;
        }

        .node.status-Êù°‰ª∂‰ªòOK {
            border-color: #f39c12;
            border-width: 3px;
        }

        .node.status-NG {
            border-color: #e74c3c;
            border-width: 3px;
        }

        .node.status-Âç¥‰∏ã {
            background-color: #e0e0e0;
        }

        .node.status-‰øùÁïô {
            background-color: #e6d5f5;
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
            gap: 10px;
        }

        .node-left-section {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 80px;
        }

        .node-id-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        /* „ÉÜ„Çπ„ÉàÁ®ÆÂà•„Éó„É´„ÉÄ„Ç¶„É≥ */
        .test-type {
            padding: 4px 8px;
            border: 2px solid #667eea;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            width: 100%;
        }

        .test-type:focus {
            outline: none;
            border-color: #5568d3;
        }

        .test-type.type-Ê≠£Â∏∏Á≥ª {
            background-color: #2ecc71;
            color: white;
            border-color: #27ae60;
        }

        .test-type.type-Áï∞Â∏∏Á≥ª {
            background-color: #e74c3c;
            color: white;
            border-color: #c0392b;
        }

        .test-type.type-„Åù„ÅÆ‰ªñ {
            background-color: #95a5a6;
            color: white;
            border-color: #7f8c8d;
        }

        .node-id {
            font-weight: bold;
            color: #667eea;
            font-size: 14px;
            min-width: 60px;
            padding: 4px 8px;
            background: #f0f4ff;
            border-radius: 4px;
            cursor: text;
            border: 1px solid transparent;
            transition: all 0.2s;
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: break-word;
        }

        .node-id:hover {
            border-color: #667eea;
        }

        .node-id:focus {
            outline: none;
            border-color: #667eea;
            background: white;
        }

        .node-status {
            padding: 4px 10px;
            border: 2px solid #667eea;
            border-radius: 4px;
            background: white;
            color: #333;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            width: 100%;
        }

        .node-status:hover {
            background: #f0f4ff;
        }

        .node-status:focus {
            outline: none;
            border-color: #5568d3;
        }

        .node-status.status-Ëµ∑Á•® {
            border-color: #95a5a6;
            color: #95a5a6;
        }

        .node-status.status-OK {
            border-color: #2ecc71;
            color: #2ecc71;
        }

        .node-status.status-Êù°‰ª∂‰ªòOK {
            border-color: #f39c12;
            color: #f39c12;
        }

        .node-status.status-NG {
            border-color: #e74c3c;
            color: #e74c3c;
        }

        .node-status.status-Âç¥‰∏ã {
            border-color: #95a5a6;
            color: #95a5a6;
        }

        .node-status.status-‰øùÁïô {
            border-color: #95a5a6;
            color: #95a5a6;
        }

        .node-status option:disabled {
            color: #ccc;
        }

        .node-controls {
            display: flex;
            gap: 5px;
        }

        .node-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .node-btn:hover {
            background: #5568d3;
        }

        .node-btn.delete {
            background: #ff6b6b;
        }

        .node-btn.delete:hover {
            background: #ee5a52;
        }

        .node-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        .node-content:hover {
            background-color: #f8f9fa;
        }

        .node-content h1 { font-size: 1.5em; margin: 0.5em 0; word-wrap: break-word; }
        .node-content h2 { font-size: 1.3em; margin: 0.5em 0; word-wrap: break-word; }
        .node-content h3 { font-size: 1.1em; margin: 0.5em 0; word-wrap: break-word; }
        .node-content p { margin: 0.5em 0; word-wrap: break-word; }
        .node-content ul, .node-content ol { margin-left: 1.5em; }
        .node-content li { word-wrap: break-word; }
        .node-content code { 
            background: #f4f4f4; 
            padding: 2px 6px; 
            border-radius: 3px;
            font-family: monospace;
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: break-word;
        }
        .node-content pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        .node-content pre code {
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        .node-content strong { font-weight: bold; }
        .node-content em { font-style: italic; }

        .edit-mode {
            display: none;
            height: 100%;
        }

        .node.editing .edit-mode {
            display: flex;
            flex-direction: column;
        }

        .node.editing .view-mode {
            display: none;
        }

        .node-textarea {
            width: 100%;
            height: 100%;
            min-height: 100px;
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            resize: none;
            box-sizing: border-box;
        }

        .toolbar {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }

        .toolbar button {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            margin-right: 10px;
        }

        .toolbar button:hover {
            background: #5568d3;
        }

        .info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            font-size: 12px;
            color: #333;
            max-width: 300px;
        }

        .info h3 {
            margin-bottom: 8px;
            color: #667eea;
            font-size: 14px;
        }

        .info ul {
            list-style: none;
            padding: 0;
        }

        .info li {
            margin-bottom: 5px;
            padding-left: 15px;
            position: relative;
        }

        .info li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: #667eea;
        }

        .connection {
            stroke: white;
            stroke-width: 2;
            opacity: 0.8;
            pointer-events: stroke;
            cursor: pointer;
            marker-end: url(#arrowhead);
        }

        .connection:hover {
            stroke-width: 4;
            opacity: 1;
        }

        .context-menu {
            position: fixed;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            min-width: 150px;
            display: none;
        }

        .context-menu.show {
            display: block;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
            color: #333;
            border-bottom: 1px solid #e0e0e0;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: #f0f4ff;
        }

        .context-menu-item:first-child {
            border-radius: 6px 6px 0 0;
        }

        .context-menu-item:last-child {
            border-radius: 0 0 6px 6px;
        }

        .context-menu-item.delete {
            color: #e74c3c;
            font-weight: 500;
        }

        .context-menu-item.delete:hover {
            background: #fee;
        }

        /* „Ç®„ÇØ„Çπ„Éù„Éº„Éà„É°„Éã„É•„Éº */
        .export-menu {
            position: fixed;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            min-width: 180px;
            display: none;
            padding: 10px;
        }

        .export-menu.show {
            display: block;
        }

        .export-menu h4 {
            margin: 0 0 10px 0;
            color: #667eea;
            font-size: 14px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }

        .export-menu button {
            width: 100%;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            margin-bottom: 6px;
            text-align: left;
        }

        .export-menu button:last-child {
            margin-bottom: 0;
        }

        .export-menu button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button id="addNodeBtn">‚ûï „Éé„Éº„ÉâËøΩÂä†</button>
        <button id="clearBtn">üóëÔ∏è „Åô„Åπ„Å¶„ÇØ„É™„Ç¢</button>
        <button id="importBtn">üìÇ „Ç§„É≥„Éù„Éº„Éà</button>
        <button id="exportBtn">üíæ „Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>
    </div>
    
    <input type="file" id="fileInput" accept=".tsv,.json" style="display: none;">

    <div class="info">
        <h3>üìù Êìç‰ΩúÊñπÊ≥ï</h3>
        <ul>
            <li>„Éé„Éº„Éâ„Çí„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÁßªÂãï</li>
            <li>„Éé„Éº„Éâ„ÅÆ4Ëæ∫„Çí„Éâ„É©„ÉÉ„Ç∞„Åß„É™„Çµ„Ç§„Ç∫</li>
            <li>„ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Á∑®ÈõÜ</li>
            <li>Á®ÆÂà•„ÅßÊ≠£Â∏∏Á≥ª/Áï∞Â∏∏Á≥ª„ÇíÈÅ∏Êäû</li>
            <li>„Çπ„ÉÜ„Éº„Çø„Çπ„Åß„Éé„Éº„Éâ„ÅÆË¶ã„ÅüÁõÆ„ÅåÂ§âÂåñ</li>
            <li>„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥ÈÉ®ÂàÜ„Çí„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÁ∑®ÈõÜ</li>
            <li>Á∑®ÈõÜ‰∏≠„ÅØÂ§ñÂÅ¥„ÇØ„É™„ÉÉ„ÇØ„ÅßËá™Âãï‰øùÂ≠ò</li>
            <li>„Éé„Éº„Éâ„ÅÆ4ÊñπÂêë„ÅÆÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Êé•Á∂ö</li>
            <li>„Éé„Éº„Éâ„ÇíÂè≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÂâäÈô§</li>
            <li>Êé•Á∂öÁ∑ö„ÇíÂè≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÂâäÈô§</li>
            <li>ËÉåÊôØ„Çí„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÂÖ®‰ΩìÁßªÂãï</li>
        </ul>
    </div>

    <div id="canvas">
        <svg id="svg"></svg>
    </div>

    <div id="contextMenu" class="context-menu">
        <div class="context-menu-item delete" id="deleteNode">üóëÔ∏è „Éé„Éº„Éâ„ÇíÂâäÈô§</div>
        <div class="context-menu-item delete" id="deleteConnection">üóëÔ∏è Êé•Á∂ö„ÇíÂâäÈô§</div>
    </div>

    <div id="exportMenu" class="export-menu">
        <h4>üì• „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂΩ¢Âºè„ÇíÈÅ∏Êäû</h4>
        <button id="exportTsvBtn">üìÑ TSVÂΩ¢Âºè</button>
        <button id="exportJsonBtn">üìã JSONÂΩ¢Âºè</button>
        <button id="exportSvgBtn">üñºÔ∏è SVGÂΩ¢Âºè</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const svg = document.getElementById('svg');
        const addNodeBtn = document.getElementById('addNodeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const importBtn = document.getElementById('importBtn');
        const exportBtn = document.getElementById('exportBtn');
        const fileInput = document.getElementById('fileInput');
        const contextMenu = document.getElementById('contextMenu');
        const exportMenu = document.getElementById('exportMenu');
        const deleteNodeBtn = document.getElementById('deleteNode');
        const deleteConnectionBtn = document.getElementById('deleteConnection');
        const exportTsvBtn = document.getElementById('exportTsvBtn');
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const exportSvgBtn = document.getElementById('exportSvgBtn');

        let nodes = [];
        let connections = [];
        let nodeIdCounter = 0;
        let isDraggingCanvas = false;
        let dragStart = { x: 0, y: 0 };
        let selectedConnection = null;
        let selectedNode = null;
        let connectingFrom = null;

        // UUIDÁîüÊàêÈñ¢Êï∞
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // UNIXÊôÇÈñìÂèñÂæó
        function getUnixTime() {
            return Math.floor(Date.now() / 1000);
        }

        // ‰∏ÄÊÑè„ÅÆ„Éé„Éº„ÉâIDÁîüÊàê
        function generateNodeUniqueId() {
            return `${generateUUID()}_${getUnixTime()}`;
        }

        // „Éé„Éº„Éâ‰ΩúÊàê
        function createNode(x, y, content = '# Êñ∞„Åó„ÅÑ„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ\n\nÂÜÖÂÆπ„ÇíË®òËø∞...') {
            const nodeId = nodeIdCounter++;
            const node = document.createElement('div');
            node.className = 'node';
            node.style.left = x + 'px';
            node.style.top = y + 'px';
            
            node.innerHTML = `
                <div class="resize-handle top"></div>
                <div class="resize-handle bottom"></div>
                <div class="resize-handle left"></div>
                <div class="resize-handle right"></div>
                <div class="connector top" data-direction="top"></div>
                <div class="connector bottom" data-direction="bottom"></div>
                <div class="connector left" data-direction="left"></div>
                <div class="connector right" data-direction="right"></div>
                <div class="node-header">
                    <div class="node-left-section">
                        <select class="test-type type-Ê≠£Â∏∏Á≥ª">
                            <option value="Ê≠£Â∏∏Á≥ª">Ê≠£Â∏∏Á≥ª</option>
                            <option value="Áï∞Â∏∏Á≥ª">Áï∞Â∏∏Á≥ª</option>
                            <option value="„Åù„ÅÆ‰ªñ">„Åù„ÅÆ‰ªñ</option>
                        </select>
                        <select class="node-status status-Ëµ∑Á•®">
                            <option value="Ëµ∑Á•®">Ëµ∑Á•®</option>
                            <option value="OK">OK</option>
                            <option value="Êù°‰ª∂‰ªòOK">Êù°‰ª∂‰ªòOK</option>
                            <option value="NG">NG</option>
                            <option value="Âç¥‰∏ã">Âç¥‰∏ã</option>
                            <option value="‰øùÁïô">‰øùÁïô</option>
                        </select>
                    </div>
                    <div class="node-id-container">
                        <div class="node-id" contenteditable="true">TC-${String(nodeId + 1).padStart(3, '0')}</div>
                    </div>
                </div>
                <div class="view-mode">
                    <div class="node-content"></div>
                </div>
                <div class="edit-mode">
                    <textarea class="node-textarea">${content}</textarea>
                </div>
            `;

            const nodeData = {
                id: nodeId,
                uniqueId: generateNodeUniqueId(),
                element: node,
                x: x,
                y: y,
                width: null,
                height: null,
                content: content,
                testCaseId: `TC-${String(nodeId + 1).padStart(3, '0')}`,
                status: 'Ëµ∑Á•®',
                testType: 'Ê≠£Â∏∏Á≥ª'
            };

            nodes.push(nodeData);
            canvas.appendChild(node);

            // „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„É¨„É≥„ÉÄ„É™„É≥„Ç∞
            updateNodeContent(nodeData);

            // ÂàùÊúü„Çµ„Ç§„Ç∫„ÇíË®òÈå≤
            setTimeout(() => {
                if (!nodeData.width) {
                    nodeData.width = node.offsetWidth;
                }
                if (!nodeData.height) {
                    nodeData.height = node.offsetHeight;
                }
            }, 0);

            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            setupNodeEvents(nodeData);
            
            // „Çπ„ÉÜ„Éº„Çø„Çπ„Ç™„Éó„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞
            updateStatusOptions(nodeData);

            return nodeData;
        }

        // „Éé„Éº„Éâ„Ç≥„É≥„ÉÜ„É≥„ÉÑÊõ¥Êñ∞
        function updateNodeContent(nodeData) {
            const contentDiv = nodeData.element.querySelector('.node-content');
            contentDiv.innerHTML = marked.parse(nodeData.content);
        }

        // „Éé„Éº„Éâ„ÅÆË¶ã„ÅüÁõÆ„ÇíÊõ¥Êñ∞
        function updateNodeAppearance(nodeData) {
            const node = nodeData.element;
            
            // „Çπ„ÉÜ„Éº„Çø„Çπ„Å´„Çà„Çã„Éé„Éº„Éâ„ÇØ„É©„Çπ„ÅÆÊõ¥Êñ∞
            node.classList.remove('status-Ëµ∑Á•®', 'status-OK', 'status-Êù°‰ª∂‰ªòOK', 'status-NG', 'status-Âç¥‰∏ã', 'status-‰øùÁïô');
            node.classList.add(`status-${nodeData.status}`);
        }

        // ÂÖàË°å„Éé„Éº„Éâ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        function checkPredecessorStatus(nodeData) {
            // „Åì„ÅÆ„Éé„Éº„Éâ„Å´Êé•Á∂ö„Åó„Å¶„ÅÑ„ÇãÂÖàË°å„Éé„Éº„ÉâÔºàfrom„Éé„Éº„ÉâÔºâ„ÇíÂèñÂæó
            const predecessorConnections = connections.filter(conn => conn.to === nodeData.id);
            
            if (predecessorConnections.length === 0) {
                // ÂÖàË°å„Éé„Éº„Éâ„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÂà∂Á¥Ñ„Å™„Åó
                return true;
            }
            
            // „Åô„Åπ„Å¶„ÅÆÂÖàË°å„Éé„Éº„Éâ„ÅåOK/Êù°‰ª∂‰ªòOK/Âç¥‰∏ã/‰øùÁïô„ÅÆ„ÅÑ„Åö„Çå„Åã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            const allPredecessorsOk = predecessorConnections.every(conn => {
                const predecessorNode = nodes.find(n => n.id === conn.from);
                return predecessorNode && (
                    predecessorNode.status === 'OK' || 
                    predecessorNode.status === 'Êù°‰ª∂‰ªòOK' ||
                    predecessorNode.status === 'Âç¥‰∏ã' ||
                    predecessorNode.status === '‰øùÁïô'
                );
            });
            
            return allPredecessorsOk;
        }

        // „Çπ„ÉÜ„Éº„Çø„Çπ„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞ÔºàÂà∂Á¥Ñ„Å´Âü∫„Å•„ÅÑ„Å¶ÁÑ°ÂäπÂåñÔºâ
        function updateStatusOptions(nodeData) {
            const statusSelect = nodeData.element.querySelector('.node-status');
            const canSetTestResult = checkPredecessorStatus(nodeData);
            
            // „Ç™„Éó„Ç∑„Éß„É≥„ÇíÂèñÂæó
            const options = statusSelect.querySelectorAll('option');
            
            options.forEach(option => {
                const value = option.value;
                
                if (value === 'OK' || value === 'Êù°‰ª∂‰ªòOK' || value === 'NG') {
                    if (!canSetTestResult) {
                        option.disabled = true;
                        // Èçµ„Ç¢„Ç§„Ç≥„É≥„ÇíËøΩÂä†
                        if (!option.textContent.startsWith('üîí ')) {
                            option.textContent = 'üîí ' + option.value;
                        }
                    } else {
                        option.disabled = false;
                        // Èçµ„Ç¢„Ç§„Ç≥„É≥„ÇíÂâäÈô§
                        option.textContent = option.value;
                    }
                } else {
                    option.disabled = false;
                    option.textContent = option.value;
                }
            });
            
            // ÁèæÂú®„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„ÅåÁÑ°ÂäπÂåñ„Åï„Çå„ÅüÂ†¥Âêà„ÄÅËµ∑Á•®„Å´Êàª„Åô
            if (!canSetTestResult && (nodeData.status === 'OK' || nodeData.status === 'Êù°‰ª∂‰ªòOK' || nodeData.status === 'NG')) {
                nodeData.status = 'Ëµ∑Á•®';
                statusSelect.value = 'Ëµ∑Á•®';
                statusSelect.className = 'node-status status-Ëµ∑Á•®';
                updateNodeAppearance(nodeData);
            }
        }

        // „Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éâ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„Ç™„Éó„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞
        function updateAllStatusOptions() {
            nodes.forEach(node => {
                updateStatusOptions(node);
            });
        }

        // „Éé„Éº„Éâ„Ç§„Éô„É≥„ÉàË®≠ÂÆö
        function setupNodeEvents(nodeData) {
            const node = nodeData.element;
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            // „ÉÜ„Çπ„ÉàÁ®ÆÂà•Â§âÊõ¥
            const testTypeSelect = node.querySelector('.test-type');
            testTypeSelect.addEventListener('change', (e) => {
                nodeData.testType = e.target.value;
                testTypeSelect.className = `test-type type-${e.target.value}`;
            });

            // „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπIDÁ∑®ÈõÜ
            const nodeIdInput = node.querySelector('.node-id');
            nodeIdInput.addEventListener('blur', () => {
                nodeData.testCaseId = nodeIdInput.textContent;
            });

            nodeIdInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    nodeIdInput.blur();
                }
            });

            // „Çπ„ÉÜ„Éº„Çø„ÇπÂ§âÊõ¥
            const statusSelect = node.querySelector('.node-status');
            statusSelect.addEventListener('change', (e) => {
                const newStatus = e.target.value;
                
                // Âà∂Á¥Ñ„ÉÅ„Çß„ÉÉ„ÇØ
                if ((newStatus === 'OK' || newStatus === 'Êù°‰ª∂‰ªòOK' || newStatus === 'NG') && !checkPredecessorStatus(nodeData)) {
                    alert('ÂÖàË°å„ÅÆ„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÅåOK/Êù°‰ª∂‰ªòOK/Âç¥‰∏ã/‰øùÁïô„ÅÆ„ÅÑ„Åö„Çå„Åã„Å´„Å™„Å£„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅ„ÄÅ„Åì„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„ÅØÈÅ∏Êäû„Åß„Åç„Åæ„Åõ„Çì„ÄÇ');
                    e.target.value = nodeData.status;
                    return;
                }
                
                nodeData.status = newStatus;
                statusSelect.className = `node-status status-${newStatus}`;
                updateNodeAppearance(nodeData);
                
                // „Åì„ÅÆ„Éé„Éº„Éâ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„ÅåÂ§âÊõ¥„Åï„Çå„Åü„Çâ„ÄÅÂæåÁ∂ö„Éé„Éº„Éâ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„Ç™„Éó„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞
                updateAllStatusOptions();
            });

            // „Éâ„É©„ÉÉ„Ç∞ÈñãÂßã
            node.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'BUTTON' || 
                    e.target.tagName === 'TEXTAREA' || 
                    e.target.tagName === 'SELECT' || 
                    e.target.classList.contains('node-id') ||
                    e.target.classList.contains('connector') ||
                    e.target.classList.contains('resize-handle')) return;
                
                isDragging = true;
                node.classList.add('dragging');
                dragOffset.x = e.clientX - nodeData.x;
                dragOffset.y = e.clientY - nodeData.y;
                e.stopPropagation();
            });

            // „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥ÈÉ®ÂàÜ„ÅÆ„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÁ∑®ÈõÜ„É¢„Éº„Éâ„Å´
            const contentDiv = node.querySelector('.node-content');
            contentDiv.addEventListener('dblclick', () => {
                // ÁèæÂú®„ÅÆ„Éé„Éº„Éâ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó„Åó„Å¶Âõ∫ÂÆö
                const currentWidth = node.offsetWidth;
                const currentHeight = node.offsetHeight;
                
                // „Éé„Éº„Éâ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö
                if (!nodeData.width || nodeData.width < currentWidth) {
                    nodeData.width = currentWidth;
                }
                if (!nodeData.height || nodeData.height < currentHeight) {
                    nodeData.height = currentHeight;
                }
                
                node.style.width = nodeData.width + 'px';
                node.style.height = nodeData.height + 'px';
                
                node.classList.add('editing');
                const textarea = node.querySelector('.node-textarea');
                textarea.focus();
            });

            // „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢Â§ñ„ÇØ„É™„ÉÉ„ÇØ„Åß‰øùÂ≠ò
            const textarea = node.querySelector('.node-textarea');
            document.addEventListener('click', (e) => {
                if (node.classList.contains('editing')) {
                    // „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„Å®„Åù„ÅÆË¶™Ë¶ÅÁ¥†‰ª•Â§ñ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÂ†¥Âêà
                    if (!textarea.contains(e.target) && !node.contains(e.target)) {
                        nodeData.content = textarea.value;
                        updateNodeContent(nodeData);
                        node.classList.remove('editing');
                    } else if (node.contains(e.target) && !textarea.contains(e.target) && e.target.tagName !== 'TEXTAREA') {
                        // „Éé„Éº„ÉâÂÜÖ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢‰ª•Â§ñ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÂ†¥Âêà
                        nodeData.content = textarea.value;
                        updateNodeContent(nodeData);
                        node.classList.remove('editing');
                    }
                }
            });

            // „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´„ÅÆ„Ç§„Éô„É≥„Éà
            const resizeHandles = node.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                let isResizing = false;
                let resizeStartX = 0;
                let resizeStartY = 0;
                let startWidth = 0;
                let startHeight = 0;
                let startX = 0;
                let startY = 0;

                handle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    isResizing = true;
                    resizeStartX = e.clientX;
                    resizeStartY = e.clientY;
                    startWidth = node.offsetWidth;
                    startHeight = node.offsetHeight;
                    startX = nodeData.x;
                    startY = nodeData.y;
                    node.classList.add('resizing');

                    const handleMouseMove = (e) => {
                        if (!isResizing) return;

                        const deltaX = e.clientX - resizeStartX;
                        const deltaY = e.clientY - resizeStartY;

                        if (handle.classList.contains('right')) {
                            const newWidth = Math.max(200, startWidth + deltaX);
                            node.style.width = newWidth + 'px';
                            nodeData.width = newWidth;
                        } else if (handle.classList.contains('left')) {
                            const newWidth = Math.max(200, startWidth - deltaX);
                            if (newWidth > 200) {
                                node.style.width = newWidth + 'px';
                                nodeData.width = newWidth;
                                nodeData.x = startX + deltaX;
                                node.style.left = nodeData.x + 'px';
                            }
                        } else if (handle.classList.contains('bottom')) {
                            const newHeight = Math.max(100, startHeight + deltaY);
                            node.style.height = newHeight + 'px';
                            nodeData.height = newHeight;
                        } else if (handle.classList.contains('top')) {
                            const newHeight = Math.max(100, startHeight - deltaY);
                            if (newHeight > 100) {
                                node.style.height = newHeight + 'px';
                                nodeData.height = newHeight;
                                nodeData.y = startY + deltaY;
                                node.style.top = nodeData.y + 'px';
                            }
                        }

                        updateConnections();
                    };

                    const handleMouseUp = () => {
                        if (isResizing) {
                            isResizing = false;
                            node.classList.remove('resizing');
                            document.removeEventListener('mousemove', handleMouseMove);
                            document.removeEventListener('mouseup', handleMouseUp);
                        }
                    };

                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                });
            });

            // „Éé„Éº„Éâ„ÅÆÂè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº
            node.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                selectedNode = nodeData;
                selectedConnection = null;
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
                contextMenu.classList.add('show');
                
                // „É°„Éã„É•„ÉºÈ†ÖÁõÆ„ÅÆË°®Á§∫/ÈùûË°®Á§∫
                deleteNodeBtn.style.display = 'block';
                deleteConnectionBtn.style.display = 'none';
            });

            // „Ç≥„Éç„ÇØ„Çø„Éº„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
            const connectors = node.querySelectorAll('.connector');
            connectors.forEach(connector => {
                connector.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleConnectorClick(nodeData, connector);
                });
            });

            // „Éû„Ç¶„ÇπÁßªÂãï
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    nodeData.x = e.clientX - dragOffset.x;
                    nodeData.y = e.clientY - dragOffset.y;
                    node.style.left = nodeData.x + 'px';
                    node.style.top = nodeData.y + 'px';
                    updateConnections();
                }
            });

            // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫Ü
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    node.classList.remove('dragging');
                }
            });
        }

        // „Éé„Éº„ÉâÂâäÈô§
        function deleteNode(nodeData) {
            nodeData.element.remove();
            nodes = nodes.filter(n => n.id !== nodeData.id);
            connections = connections.filter(c => c.from !== nodeData.id && c.to !== nodeData.id);
            updateConnections();
        }

        // Êé•Á∂ö‰ΩúÊàê
        function createConnection(fromNodeId, toNodeId, fromDirection, toDirection) {
            connections.push({ 
                from: fromNodeId, 
                to: toNodeId,
                fromDirection: fromDirection || 'center',
                toDirection: toDirection || 'center'
            });
            updateConnections();
            
            // Êé•Á∂ö„Åå‰ΩúÊàê„Åï„Çå„Åü„Çâ„ÄÅ„Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éâ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„Ç™„Éó„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞
            updateAllStatusOptions();
        }

        // „Ç≥„Éç„ÇØ„Çø„Éº„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ
        function handleConnectorClick(nodeData, connector) {
            const direction = connector.dataset.direction;
            
            if (!connectingFrom) {
                // Êé•Á∂öÈñãÂßã
                connectingFrom = {
                    node: nodeData,
                    direction: direction,
                    connector: connector
                };
                connector.classList.add('active');
            } else {
                // Êé•Á∂öÂÆå‰∫Ü
                if (connectingFrom.node.id !== nodeData.id) {
                    createConnection(
                        connectingFrom.node.id, 
                        nodeData.id,
                        connectingFrom.direction,
                        direction
                    );
                }
                // „Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖã„ÇíËß£Èô§
                const activeConnectors = document.querySelectorAll('.connector.active');
                activeConnectors.forEach(c => c.classList.remove('active'));
                connectingFrom = null;
            }
        }

        // TSV„Ç®„Çπ„Ç±„Éº„ÉóÈñ¢Êï∞Ôºà„Éê„ÉÉ„ÇØ„Çπ„É©„ÉÉ„Ç∑„É•„Åß„Ç®„Çπ„Ç±„Éº„ÉóÔºâ
        function escapeTsv(value) {
            if (value == null) return '';
            const stringValue = String(value);
            // „Éê„ÉÉ„ÇØ„Çπ„É©„ÉÉ„Ç∑„É•„ÄÅ„Çø„Éñ„ÄÅÊîπË°å„ÄÅ„Ç≠„É£„É™„ÉÉ„Ç∏„É™„Çø„Éº„É≥„Çí„Ç®„Çπ„Ç±„Éº„Éó
            return stringValue
                .replace(/\\/g, '\\\\')  // „Éê„ÉÉ„ÇØ„Çπ„É©„ÉÉ„Ç∑„É•
                .replace(/\t/g, '\\t')   // „Çø„Éñ
                .replace(/\n/g, '\\n')   // ÊîπË°å
                .replace(/\r/g, '\\r');  // „Ç≠„É£„É™„ÉÉ„Ç∏„É™„Çø„Éº„É≥
        }

        // TSVÂΩ¢Âºè„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà
        function exportToTsv() {
            // „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
            const duplicates = checkDuplicateTestCaseIds();
            if (duplicates.length > 0) {
                alert('ÈáçË§á„ÅÆ„ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ‰∏ÄÊÑè„ÅÆÂÄ§„ÇíÁôªÈå≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\nÈáçË§áID: ' + duplicates.join(', '));
                return;
            }

            // „Éò„ÉÉ„ÉÄ„ÉºË°åÔºàËã±Ë™ûÔºâ
            const headers = [
                'unique_id',
                'test_case_id',
                'test_type',
                'status',
                'markdown_content',
                'height',
                'width',
                'x_position',
                'y_position',
                'connected_node_ids'
            ];

            let tsvContent = headers.join('\t') + '\n';

            // „Éá„Éº„ÇøË°å
            nodes.forEach(node => {
                // Êé•Á∂öÂÖà„ÅÆ„Éé„Éº„ÉâID„É™„Çπ„Éà„ÇíÂèñÂæóÔºàÊñπÂêëÊÉÖÂ†±‰ªò„ÅçÔºâ
                const connectedToNodeIds = connections
                    .filter(conn => conn.from === node.id)
                    .map(conn => {
                        const targetNode = nodes.find(n => n.id === conn.to);
                        return targetNode ? {
                            direction: 'to',
                            node_id: targetNode.uniqueId,
                            connect_point: conn.fromDirection || 'center'
                        } : null;
                    })
                    .filter(conn => conn !== null);

                // Êé•Á∂öÂÖÉ„ÅÆ„Éé„Éº„ÉâID„É™„Çπ„Éà„ÇÇÂèñÂæó
                const connectedFromNodeIds = connections
                    .filter(conn => conn.to === node.id)
                    .map(conn => {
                        const sourceNode = nodes.find(n => n.id === conn.from);
                        return sourceNode ? {
                            direction: 'from',
                            node_id: sourceNode.uniqueId,
                            connect_point: conn.toDirection || 'center'
                        } : null;
                    })
                    .filter(conn => conn !== null);

                // ‰∏°Êñπ„ÇíÁµêÂêà„Åó„Å¶JSONÊñáÂ≠óÂàóÂåñ
                const allConnections = [...connectedToNodeIds, ...connectedFromNodeIds];
                const connectionsJson = JSON.stringify(allConnections);

                const row = [
                    escapeTsv(node.uniqueId),
                    escapeTsv(node.testCaseId.trim()),
                    escapeTsv(node.testType),
                    escapeTsv(node.status),
                    escapeTsv(node.content),
                    escapeTsv(node.height || node.element.offsetHeight),
                    escapeTsv(node.width || node.element.offsetWidth),
                    escapeTsv(node.x),
                    escapeTsv(node.y),
                    escapeTsv(connectionsJson)
                ];

                tsvContent += row.join('\t') + '\n';
            });

            // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            const blob = new Blob([tsvContent], { type: 'text/tab-separated-values;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.setAttribute('href', url);
            link.setAttribute('download', `test_mindmap_${timestamp}.tsv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // JSONÂΩ¢Âºè„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà
        function exportToJson() {
            // „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
            const duplicates = checkDuplicateTestCaseIds();
            if (duplicates.length > 0) {
                alert('ÈáçË§á„ÅÆ„ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ‰∏ÄÊÑè„ÅÆÂÄ§„ÇíÁôªÈå≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\nÈáçË§áID: ' + duplicates.join(', '));
                return;
            }

            const exportData = {
                export_date: new Date().toISOString(),
                version: '1.0',
                nodes: nodes.map(node => {
                    // Êé•Á∂öÂÖà„ÅÆ„Éé„Éº„ÉâID„É™„Çπ„Éà„ÇíÂèñÂæóÔºàÊñπÂêëÊÉÖÂ†±‰ªò„ÅçÔºâ
                    const connectedToNodeIds = connections
                        .filter(conn => conn.from === node.id)
                        .map(conn => {
                            const targetNode = nodes.find(n => n.id === conn.to);
                            return targetNode ? {
                                direction: 'to',
                                node_id: targetNode.uniqueId,
                                connect_point: conn.fromDirection || 'center'
                            } : null;
                        })
                        .filter(conn => conn !== null);

                    // Êé•Á∂öÂÖÉ„ÅÆ„Éé„Éº„ÉâID„É™„Çπ„Éà„ÇÇÂèñÂæó
                    const connectedFromNodeIds = connections
                        .filter(conn => conn.to === node.id)
                        .map(conn => {
                            const sourceNode = nodes.find(n => n.id === conn.from);
                            return sourceNode ? {
                                direction: 'from',
                                node_id: sourceNode.uniqueId,
                                connect_point: conn.toDirection || 'center'
                            } : null;
                        })
                        .filter(conn => conn !== null);

                    // ‰∏°Êñπ„ÇíÁµêÂêà
                    const allConnections = [...connectedToNodeIds, ...connectedFromNodeIds];

                    return {
                        unique_id: node.uniqueId,
                        test_case_id: node.testCaseId.trim(),
                        test_type: node.testType,
                        status: node.status,
                        markdown_content: node.content,
                        height: node.height || node.element.offsetHeight,
                        width: node.width || node.element.offsetWidth,
                        x_position: node.x,
                        y_position: node.y,
                        connected_node_ids: allConnections
                    };
                })
            };

            // JSONÊñáÂ≠óÂàó„Å´Â§âÊèõÔºàÊï¥ÂΩ¢„ÅÇ„ÇäÔºâ
            const jsonContent = JSON.stringify(exportData, null, 2);

            // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.setAttribute('href', url);
            link.setAttribute('download', `test_mindmap_${timestamp}.json`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // SVGÂΩ¢Âºè„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà
        function exportToSvg() {
            // „Ç≠„É£„É≥„Éê„Çπ„ÅÆÂ¢ÉÁïå„ÇíË®àÁÆó
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            nodes.forEach(node => {
                const rect = node.element.getBoundingClientRect();
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + rect.width);
                maxY = Math.max(maxY, node.y + rect.height);
            });

            const padding = 50;
            const viewBoxX = minX - padding;
            const viewBoxY = minY - padding;
            const viewBoxWidth = maxX - minX + padding * 2;
            const viewBoxHeight = maxY - minY + padding * 2;

            // SVGË¶ÅÁ¥†„ÅÆ‰ΩúÊàê
            let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}" width="${viewBoxWidth}" height="${viewBoxHeight}">
  <defs>
    <style>
      .node-rect { fill: white; stroke: #667eea; stroke-width: 3; }
      .node-rect-ok { stroke: #2ecc71; }
      .node-rect-ng { stroke: #e74c3c; }
      .node-rect-rejected { fill: #e0e0e0; }
      .node-rect-pending { fill: #e6d5f5; }
      .connection-line { stroke: white; stroke-width: 2; opacity: 0.8; }
      .node-text { font-family: 'Segoe UI', sans-serif; font-size: 14px; fill: #333; }
      .node-id-text { font-weight: bold; fill: #667eea; font-size: 14px; }
      .test-type-normal { fill: #2ecc71; }
      .test-type-abnormal { fill: #e74c3c; }
      .test-type-other { fill: #95a5a6; }
    </style>
  </defs>
  
  <!-- Êé•Á∂öÁ∑ö -->
  <g id="connections">
`;

            // Êé•Á∂öÁ∑ö„ÇíÊèèÁîª
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                
                if (fromNode && toNode) {
                    const fromRect = fromNode.element.getBoundingClientRect();
                    const toRect = toNode.element.getBoundingClientRect();
                    
                    const fromX = fromNode.x + fromRect.width / 2;
                    const fromY = fromNode.y + fromRect.height / 2;
                    const toX = toNode.x + toRect.width / 2;
                    const toY = toNode.y + toRect.height / 2;
                    
                    svgContent += `    <line x1="${fromX}" y1="${fromY}" x2="${toX}" y2="${toY}" class="connection-line"/>\n`;
                }
            });

            svgContent += `  </g>
  
  <!-- „Éé„Éº„Éâ -->
  <g id="nodes">
`;

            // „Éé„Éº„Éâ„ÇíÊèèÁîª
            nodes.forEach(node => {
                const rect = node.element.getBoundingClientRect();
                const width = node.width || rect.width;
                const height = node.height || rect.height;
                
                let nodeClass = 'node-rect';
                if (node.status === 'OK') nodeClass += ' node-rect-ok';
                else if (node.status === 'NG') nodeClass += ' node-rect-ng';
                else if (node.status === 'Âç¥‰∏ã') nodeClass += ' node-rect-rejected';
                else if (node.status === '‰øùÁïô') nodeClass += ' node-rect-pending';

                let typeClass = 'test-type-other';
                if (node.testType === 'Ê≠£Â∏∏Á≥ª') typeClass = 'test-type-normal';
                else if (node.testType === 'Áï∞Â∏∏Á≥ª') typeClass = 'test-type-abnormal';

                svgContent += `    <g id="node-${node.uniqueId}">
      <rect x="${node.x}" y="${node.y}" width="${width}" height="${height}" rx="12" class="${nodeClass}"/>
      
      <!-- „ÉÜ„Çπ„ÉàÁ®ÆÂà• -->
      <rect x="${node.x + 10}" y="${node.y + 10}" width="60" height="20" rx="4" class="${typeClass}"/>
      <text x="${node.x + 40}" y="${node.y + 24}" text-anchor="middle" class="node-text" fill="white" font-size="11">${node.testType}</text>
      
      <!-- „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID -->
      <text x="${node.x + 80}" y="${node.y + 24}" class="node-id-text">${escapeXml(node.testCaseId)}</text>
      
      <!-- „Çπ„ÉÜ„Éº„Çø„Çπ -->
      <text x="${node.x + width - 10}" y="${node.y + 24}" text-anchor="end" class="node-text" font-size="12">${escapeXml(node.status)}</text>
      
      <!-- „Ç≥„É≥„ÉÜ„É≥„ÉÑÔºàÁ∞°Áï•ÁâàÔºâ -->
      <text x="${node.x + 15}" y="${node.y + 45}" class="node-text">
        ${escapeXml(node.content.substring(0, 50) + (node.content.length > 50 ? '...' : ''))}
      </text>
    </g>
`;
            });

            svgContent += `  </g>
</svg>`;

            // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.setAttribute('href', url);
            link.setAttribute('download', `test_mindmap_${timestamp}.svg`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // XMLÁâπÊÆäÊñáÂ≠ó„ÅÆ„Ç®„Çπ„Ç±„Éº„Éó
        function escapeXml(text) {
            if (!text) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        // „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
        function checkDuplicateTestCaseIds() {
            const testCaseIds = nodes.map(node => node.testCaseId.trim());
            const uniqueIds = new Set();
            const duplicates = [];

            testCaseIds.forEach(id => {
                if (uniqueIds.has(id)) {
                    if (!duplicates.includes(id)) {
                        duplicates.push(id);
                    }
                } else {
                    uniqueIds.add(id);
                }
            });

            return duplicates;
        }

        // TSV„Éë„Éº„ÇπÈñ¢Êï∞Ôºà„Éê„ÉÉ„ÇØ„Çπ„É©„ÉÉ„Ç∑„É•„Ç®„Çπ„Ç±„Éº„Éó„Å´ÂØæÂøúÔºâ
        function parseTsv(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            
            return lines.map(line => {
                const fields = [];
                let currentField = '';
                let i = 0;
                
                while (i < line.length) {
                    const char = line[i];
                    
                    if (char === '\\' && i + 1 < line.length) {
                        // „Ç®„Çπ„Ç±„Éº„Éó„Ç∑„Éº„Ç±„É≥„ÇπÂá¶ÁêÜ
                        const nextChar = line[i + 1];
                        if (nextChar === '\\') {
                            currentField += '\\';
                        } else if (nextChar === 't') {
                            currentField += '\t';
                        } else if (nextChar === 'n') {
                            currentField += '\n';
                        } else if (nextChar === 'r') {
                            currentField += '\r';
                        } else {
                            currentField += nextChar;
                        }
                        i += 2;
                    } else if (char === '\t') {
                        // „Çø„Éñ„Åß„Éï„Ç£„Éº„É´„ÉâÂå∫Âàá„Çä
                        fields.push(currentField);
                        currentField = '';
                        i++;
                    } else {
                        currentField += char;
                        i++;
                    }
                }
                
                // ÊúÄÂæå„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÇíËøΩÂä†
                fields.push(currentField);
                
                return fields;
            });
        }

        // „Ç§„É≥„Éù„Éº„ÉàÈñ¢Êï∞
        function importFromFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const content = e.target.result;
                const fileName = file.name.toLowerCase();
                
                try {
                    let importData;
                    
                    if (fileName.endsWith('.json')) {
                        // JSONÂΩ¢Âºè„ÅÆ„Ç§„É≥„Éù„Éº„Éà
                        const jsonData = JSON.parse(content);
                        importData = jsonData.nodes || [];
                    } else if (fileName.endsWith('.tsv')) {
                        // TSVÂΩ¢Âºè„ÅÆ„Ç§„É≥„Éù„Éº„Éà
                        const tsvLines = parseTsv(content);
                        const headers = tsvLines[0];
                        importData = tsvLines.slice(1).map(row => {
                            const obj = {};
                            headers.forEach((header, index) => {
                                obj[header] = row[index] || '';
                            });
                            return obj;
                        });
                    } else {
                        alert('„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„Åß„Åô„ÄÇTSV„Åæ„Åü„ÅØJSON„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                        return;
                    }
                    
                    // Êó¢Â≠ò„ÅÆ„Éé„Éº„Éâ„Å®Êé•Á∂ö„Çí„ÇØ„É™„Ç¢
                    nodes.forEach(n => n.element.remove());
                    nodes = [];
                    connections = [];
                    nodeIdCounter = 0;
                    
                    // uniqueId„Åã„ÇânodeId„Å∏„ÅÆ„Éû„ÉÉ„Éî„É≥„Ç∞
                    const uniqueIdToNodeId = new Map();
                    
                    // „Éé„Éº„Éâ„ÇíÂÜç‰ΩúÊàê
                    importData.forEach(nodeInfo => {
                        const x = parseFloat(nodeInfo.x_position) || Math.random() * 600 + 100;
                        const y = parseFloat(nodeInfo.y_position) || Math.random() * 400 + 100;
                        const content = nodeInfo.markdown_content || '';
                        
                        const newNode = createNode(x, y, content);
                        
                        // „Éé„Éº„Éâ„Éá„Éº„Çø„ÇíÂæ©ÂÖÉ
                        newNode.uniqueId = nodeInfo.unique_id;
                        newNode.testCaseId = nodeInfo.test_case_id;
                        newNode.testType = nodeInfo.test_type || 'Ê≠£Â∏∏Á≥ª';
                        newNode.status = nodeInfo.status || 'Ëµ∑Á•®';
                        newNode.width = parseFloat(nodeInfo.width) || null;
                        newNode.height = parseFloat(nodeInfo.height) || null;
                        
                        // „Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö
                        if (newNode.width) {
                            newNode.element.style.width = newNode.width + 'px';
                        }
                        if (newNode.height) {
                            newNode.element.style.height = newNode.height + 'px';
                        }
                        
                        // UI„ÇíÊõ¥Êñ∞
                        const nodeIdInput = newNode.element.querySelector('.node-id');
                        nodeIdInput.textContent = newNode.testCaseId;
                        
                        const testTypeSelect = newNode.element.querySelector('.test-type');
                        testTypeSelect.value = newNode.testType;
                        testTypeSelect.className = `test-type type-${newNode.testType}`;
                        
                        const statusSelect = newNode.element.querySelector('.node-status');
                        statusSelect.value = newNode.status;
                        statusSelect.className = `node-status status-${newNode.status}`;
                        updateNodeAppearance(newNode);
                        
                        // „Éû„ÉÉ„Éî„É≥„Ç∞„Çí‰øùÂ≠ò
                        uniqueIdToNodeId.set(nodeInfo.unique_id, newNode.id);
                    });
                    
                    // Êé•Á∂ö„ÇíÂÜç‰ΩúÊàê
                    importData.forEach(nodeInfo => {
                        const fromNodeId = uniqueIdToNodeId.get(nodeInfo.unique_id);
                        if (fromNodeId === undefined || fromNodeId === null) return;
                        
                        let connectionsList;
                        try {
                            // ÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„ÅØJSON„Éë„Éº„Çπ„ÄÅÊó¢„Å´„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà„ÅØ„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®
                            connectionsList = typeof nodeInfo.connected_node_ids === 'string' 
                                ? JSON.parse(nodeInfo.connected_node_ids) 
                                : nodeInfo.connected_node_ids;
                        } catch (e) {
                            console.error('Failed to parse connected_node_ids:', e);
                            connectionsList = [];
                        }
                        
                        if (Array.isArray(connectionsList)) {
                            connectionsList.forEach(conn => {
                                if (conn.direction === 'to') {
                                    // „Åì„ÅÆ„Éé„Éº„Éâ„Åã„ÇâÁõ∏Êâã„Éé„Éº„Éâ„Å∏„ÅÆÊé•Á∂ö
                                    const toNodeId = uniqueIdToNodeId.get(conn.node_id);
                                    if (toNodeId !== undefined && toNodeId !== null) {
                                        // direction„Åå'to'„ÅÆÂ†¥Âêà„ÄÅconnect_point„ÅØfromDirectionÔºà„Åì„ÅÆ„Éé„Éº„Éâ„ÅÆÊé•Á∂öÁÇπÔºâ
                                        // Êé•Á∂öÂÖà„ÅÆÊé•Á∂öÁÇπ„ÅØ„ÄÅÁõ∏Êâã„Éé„Éº„Éâ„ÅÆconnected_node_ids„Åã„ÇâÂèñÂæó„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã
                                        
                                        // Áõ∏Êâã„Éé„Éº„Éâ„ÅÆ„Éá„Éº„Çø„ÇíÊé¢„Åô
                                        const targetNodeInfo = importData.find(n => n.unique_id === conn.node_id);
                                        let toConnectPoint = 'center';
                                        
                                        if (targetNodeInfo) {
                                            let targetConnectionsList;
                                            try {
                                                targetConnectionsList = typeof targetNodeInfo.connected_node_ids === 'string'
                                                    ? JSON.parse(targetNodeInfo.connected_node_ids)
                                                    : targetNodeInfo.connected_node_ids;
                                            } catch (e) {
                                                targetConnectionsList = [];
                                            }
                                            
                                            if (Array.isArray(targetConnectionsList)) {
                                                // Áõ∏Êâã„Éé„Éº„Éâ„ÅÆconnected_node_ids„Åã„Çâ„ÄÅ„Åì„ÅÆ„Éé„Éº„Éâ„Å∏„ÅÆ'from'Êé•Á∂ö„ÇíÊé¢„Åô
                                                const reverseConn = targetConnectionsList.find(
                                                    c => c.direction === 'from' && c.node_id === nodeInfo.unique_id
                                                );
                                                if (reverseConn) {
                                                    toConnectPoint = reverseConn.connect_point || 'center';
                                                }
                                            }
                                        }
                                        
                                        createConnection(
                                            fromNodeId, 
                                            toNodeId,
                                            conn.connect_point || 'center',
                                            toConnectPoint
                                        );
                                    }
                                }
                            });
                        }
                    });
                    
                    // „Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éâ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„Ç™„Éó„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞
                    updateAllStatusOptions();
                    
                    alert('„Ç§„É≥„Éù„Éº„Éà„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ');
                    
                } catch (error) {
                    console.error('Import error:', error);
                    alert('„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n„Ç®„É©„Éº: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        }

        // Êé•Á∂öÊõ¥Êñ∞
        function updateConnections() {
            svg.innerHTML = '<defs><marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto"><polygon points="0 0, 10 3, 0 6" fill="white" /></marker></defs>';
            
            connections.forEach((conn, index) => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                
                if (fromNode && toNode) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    
                    // „Ç≥„Éç„ÇØ„Çø„Éº„ÅÆ‰ΩçÁΩÆ„ÇíË®àÁÆó
                    const fromPos = getConnectorPosition(fromNode, conn.fromDirection || 'center');
                    const toPos = getConnectorPosition(toNode, conn.toDirection || 'center');
                    
                    line.setAttribute('x1', fromPos.x);
                    line.setAttribute('y1', fromPos.y);
                    line.setAttribute('x2', toPos.x);
                    line.setAttribute('y2', toPos.y);
                    line.classList.add('connection');
                    line.dataset.connectionIndex = index;
                    
                    // Âè≥„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
                    line.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        selectedConnection = index;
                        selectedNode = null;
                        contextMenu.style.left = e.clientX + 'px';
                        contextMenu.style.top = e.clientY + 'px';
                        contextMenu.classList.add('show');
                        
                        // „É°„Éã„É•„ÉºÈ†ÖÁõÆ„ÅÆË°®Á§∫/ÈùûË°®Á§∫
                        deleteNodeBtn.style.display = 'none';
                        deleteConnectionBtn.style.display = 'block';
                    });
                    
                    svg.appendChild(line);
                }
            });
        }

        // „Ç≥„Éç„ÇØ„Çø„Éº„ÅÆ‰ΩçÁΩÆ„ÇíÂèñÂæó
        function getConnectorPosition(nodeData, direction) {
            const rect = nodeData.element.getBoundingClientRect();
            const nodeWidth = nodeData.width || rect.width;
            const nodeHeight = nodeData.height || rect.height;
            
            let x, y;
            
            switch(direction) {
                case 'top':
                    x = nodeData.x + nodeWidth / 2;
                    y = nodeData.y;
                    break;
                case 'bottom':
                    x = nodeData.x + nodeWidth / 2;
                    y = nodeData.y + nodeHeight;
                    break;
                case 'left':
                    x = nodeData.x;
                    y = nodeData.y + nodeHeight / 2;
                    break;
                case 'right':
                    x = nodeData.x + nodeWidth;
                    y = nodeData.y + nodeHeight / 2;
                    break;
                default: // center
                    x = nodeData.x + nodeWidth / 2;
                    y = nodeData.y + nodeHeight / 2;
                    break;
            }
            
            return { x, y };
        }

        // „ÉÑ„Éº„É´„Éê„Éº„Ç§„Éô„É≥„Éà
        addNodeBtn.addEventListener('click', () => {
            createNode(Math.random() * 600 + 100, Math.random() * 400 + 100);
        });

        importBtn.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                importFromFile(file);
            }
            // „Éï„Ç°„Ç§„É´ÂÖ•Âäõ„Çí„É™„Çª„ÉÉ„ÉàÔºàÂêå„Åò„Éï„Ç°„Ç§„É´„ÇíÂÜçÂ∫¶ÈÅ∏Êäû„Åß„Åç„Çã„Çà„ÅÜ„Å´Ôºâ
            fileInput.value = '';
        });

        exportBtn.addEventListener('click', (e) => {
            const rect = exportBtn.getBoundingClientRect();
            exportMenu.style.left = rect.left + 'px';
            exportMenu.style.top = (rect.bottom + 5) + 'px';
            exportMenu.classList.add('show');
        });

        exportTsvBtn.addEventListener('click', () => {
            exportToTsv();
            exportMenu.classList.remove('show');
        });

        exportJsonBtn.addEventListener('click', () => {
            exportToJson();
            exportMenu.classList.remove('show');
        });

        exportSvgBtn.addEventListener('click', () => {
            exportToSvg();
            exportMenu.classList.remove('show');
        });

        clearBtn.addEventListener('click', () => {
            if (confirm('Êú¨ÂΩì„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                nodes.forEach(n => n.element.remove());
                nodes = [];
                connections = [];
                updateConnections();
            }
        });

        // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„ÅÆ„Éé„Éº„ÉâÂâäÈô§
        deleteNodeBtn.addEventListener('click', () => {
            if (selectedNode !== null) {
                if (confirm('Êú¨ÂΩì„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                    deleteNode(selectedNode);
                    contextMenu.classList.remove('show');
                    selectedNode = null;
                }
            }
        });

        // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„ÅÆÊé•Á∂öÂâäÈô§
        deleteConnectionBtn.addEventListener('click', () => {
            if (selectedConnection !== null) {
                connections.splice(selectedConnection, 1);
                updateConnections();
                contextMenu.classList.remove('show');
                selectedConnection = null;
                
                // Êé•Á∂ö„ÅåÂâäÈô§„Åï„Çå„Åü„Çâ„ÄÅ„Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éâ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„Ç™„Éó„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞
                updateAllStatusOptions();
            }
        });

        // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„ÇíÈñâ„Åò„Çã
        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.classList.remove('show');
            }
            if (!exportMenu.contains(e.target) && !exportBtn.contains(e.target)) {
                exportMenu.classList.remove('show');
            }
        });

        // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãÊôÇ„Å´„Çπ„ÇØ„É≠„Éº„É´„ÇÑ„É™„Çµ„Ç§„Ç∫„ÅßÈñâ„Åò„Çã
        window.addEventListener('scroll', () => {
            contextMenu.classList.remove('show');
            exportMenu.classList.remove('show');
        });

        window.addEventListener('resize', () => {
            contextMenu.classList.remove('show');
            exportMenu.classList.remove('show');
        });

        // „Ç≠„É£„É≥„Éê„Çπ„Éâ„É©„ÉÉ„Ç∞
        canvas.addEventListener('mousedown', (e) => {
            if (e.target === canvas || e.target === svg) {
                isDraggingCanvas = true;
                canvas.classList.add('grabbing');
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingCanvas) {
                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;
                
                nodes.forEach(nodeData => {
                    nodeData.x += dx;
                    nodeData.y += dy;
                    nodeData.element.style.left = nodeData.x + 'px';
                    nodeData.element.style.top = nodeData.y + 'px';
                });
                
                updateConnections();
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingCanvas = false;
            canvas.classList.remove('grabbing');
        });

        // ÂàùÊúü„Éé„Éº„Éâ‰ΩúÊàêÔºà„Éá„É¢Áî®Ôºâ
        const node1 = createNode(200, 150, '# „É≠„Ç∞„Ç§„É≥Ê©üËÉΩ„ÉÜ„Çπ„Éà\n\n## ÂâçÊèêÊù°‰ª∂\n- „É¶„Éº„Ç∂„Éº„ÅåÁôªÈå≤Ê∏à„Åø\n- „É≠„Ç∞„Ç§„É≥ÁîªÈù¢„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Çã\n\n## „ÉÜ„Çπ„ÉàÊâãÈ†Ü\n1. „É¶„Éº„Ç∂„ÉºID„ÇíÂÖ•Âäõ\n2. „Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ\n3. „É≠„Ç∞„Ç§„É≥„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ\n\n## ÊúüÂæÖÁµêÊûú\n„Éõ„Éº„É†ÁîªÈù¢„ÅåË°®Á§∫„Åï„Çå„Çã');
        const node2 = createNode(550, 100, '# Ê≠£Â∏∏Á≥ª„ÉÜ„Çπ„Éà\n\n## ÊâãÈ†Ü\n- ÊúâÂäπ„Å™ID/PW„ÇíÂÖ•Âäõ\n\n## ÁµêÊûú\n**ÊàêÂäü**„Åó„Å¶„É≠„Ç∞„Ç§„É≥„Åß„Åç„Çã');
        const node3 = createNode(550, 300, '# Áï∞Â∏∏Á≥ª„ÉÜ„Çπ„Éà\n\n## ÊâãÈ†Ü\n- ÁÑ°Âäπ„Å™PW„ÇíÂÖ•Âäõ\n\n## ÁµêÊûú\n`„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏`„ÅåË°®Á§∫„Åï„Çå„Çã');
        
        // ÂàùÊúü„Éé„Éº„Éâ„ÅÆ„ÉÜ„Çπ„ÉàÁ®ÆÂà•„ÇíË®≠ÂÆö
        node2.testType = 'Ê≠£Â∏∏Á≥ª';
        node2.element.querySelector('.test-type').value = 'Ê≠£Â∏∏Á≥ª';
        node2.element.querySelector('.test-type').className = 'test-type type-Ê≠£Â∏∏Á≥ª';
        
        node3.testType = 'Áï∞Â∏∏Á≥ª';
        node3.element.querySelector('.test-type').value = 'Áï∞Â∏∏Á≥ª';
        node3.element.querySelector('.test-type').className = 'test-type type-Áï∞Â∏∏Á≥ª';
        
        createConnection(node1.id, node2.id, 'right', 'left');
        createConnection(node1.id, node3.id, 'right', 'left');
    </script>
</body>
</html>