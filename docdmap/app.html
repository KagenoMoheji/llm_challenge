<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„ÉÜ„Çπ„Éà‰ªïÊßòÊõ∏„Ç®„Éá„Ç£„Çø„Éº</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab;
        }

        #canvas.grabbing {
            cursor: grabbing;
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .node {
            position: absolute;
            background: white;
            border: 3px solid #667eea;
            border-radius: 12px;
            padding: 15px;
            min-width: 200px;
            max-width: 800px;
            min-height: 100px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: move;
            z-index: 2;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.3s, background-color 0.3s;
            resize: none;
            display: flex;
            flex-direction: column;
        }

        .node:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .node.dragging {
            opacity: 0.8;
            z-index: 1000;
        }

        .node.selected {
            border-color: #ff6b6b;
            box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.3);
        }

        .node.resizing {
            transition: none;
        }

        .node.resizing:hover {
            transform: none;
        }

        .view-mode {
            flex: 1;
            overflow: auto;
        }

        /* „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´ */
        .resize-handle {
            position: absolute;
            background: transparent;
            z-index: 11;
        }

        .resize-handle.top {
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
        }

        .resize-handle.bottom {
            bottom: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
        }

        .resize-handle.left {
            left: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
        }

        .resize-handle.right {
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
        }

        .resize-handle:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        /* „Ç≥„Éç„ÇØ„Çø„Éº */
        .connector {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #667eea;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s;
            opacity: 0;
        }

        .node:hover .connector {
            opacity: 1;
        }

        .connector:hover {
            width: 16px;
            height: 16px;
            background: #5568d3;
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.6);
        }

        .connector.active {
            opacity: 1;
            background: #ff6b6b;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3);
            }
        }

        .connector.top {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connector.bottom {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connector.left {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connector.right {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connector.top:hover,
        .connector.top.active {
            transform: translateX(-50%) scale(1.3);
        }

        .connector.bottom:hover,
        .connector.bottom.active {
            transform: translateX(-50%) scale(1.3);
        }

        .connector.left:hover,
        .connector.left.active {
            transform: translateY(-50%) scale(1.3);
        }

        .connector.right:hover,
        .connector.right.active {
            transform: translateY(-50%) scale(1.3);
        }

        /* „Çπ„ÉÜ„Éº„Çø„Çπ„Å´„Çà„Çã„Éé„Éº„Éâ„Çπ„Çø„Ç§„É´Â§âÊõ¥ */
        .node.status-OK {
            border-color: #2ecc71;
            border-width: 3px;
        }

        .node.status-NG {
            border-color: #e74c3c;
            border-width: 3px;
        }

        .node.status-Âç¥‰∏ã {
            background-color: #e0e0e0;
        }

        .node.status-‰øùÁïô {
            background-color: #e6d5f5;
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
            gap: 10px;
        }

        .node-left-section {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 80px;
        }

        .node-id-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        /* „ÉÜ„Çπ„ÉàÁ®ÆÂà•„Éó„É´„ÉÄ„Ç¶„É≥ */
        .test-type {
            padding: 4px 8px;
            border: 2px solid #667eea;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            width: 100%;
        }

        .test-type:focus {
            outline: none;
            border-color: #5568d3;
        }

        .test-type.type-Ê≠£Â∏∏Á≥ª {
            background-color: #2ecc71;
            color: white;
            border-color: #27ae60;
        }

        .test-type.type-Áï∞Â∏∏Á≥ª {
            background-color: #e74c3c;
            color: white;
            border-color: #c0392b;
        }

        .test-type.type-„Åù„ÅÆ‰ªñ {
            background-color: #95a5a6;
            color: white;
            border-color: #7f8c8d;
        }

        .node-id {
            font-weight: bold;
            color: #667eea;
            font-size: 14px;
            min-width: 60px;
            padding: 4px 8px;
            background: #f0f4ff;
            border-radius: 4px;
            cursor: text;
            border: 1px solid transparent;
            transition: all 0.2s;
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: break-word;
        }

        .node-id:hover {
            border-color: #667eea;
        }

        .node-id:focus {
            outline: none;
            border-color: #667eea;
            background: white;
        }

        .node-status {
            padding: 4px 10px;
            border: 2px solid #667eea;
            border-radius: 4px;
            background: white;
            color: #333;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            width: 100%;
        }

        .node-status:hover {
            background: #f0f4ff;
        }

        .node-status:focus {
            outline: none;
            border-color: #5568d3;
        }

        .node-status.status-Ëµ∑Á•® {
            border-color: #95a5a6;
            color: #95a5a6;
        }

        .node-status.status-OK {
            border-color: #2ecc71;
            color: #2ecc71;
        }

        .node-status.status-NG {
            border-color: #e74c3c;
            color: #e74c3c;
        }

        .node-status.status-Âç¥‰∏ã {
            border-color: #95a5a6;
            color: #95a5a6;
        }

        .node-status.status-‰øùÁïô {
            border-color: #95a5a6;
            color: #95a5a6;
        }

        .node-controls {
            display: flex;
            gap: 5px;
        }

        .node-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .node-btn:hover {
            background: #5568d3;
        }

        .node-btn.delete {
            background: #ff6b6b;
        }

        .node-btn.delete:hover {
            background: #ee5a52;
        }

        .node-content {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        .node-content:hover {
            background-color: #f8f9fa;
        }

        .node-content h1 { font-size: 1.5em; margin: 0.5em 0; word-wrap: break-word; }
        .node-content h2 { font-size: 1.3em; margin: 0.5em 0; word-wrap: break-word; }
        .node-content h3 { font-size: 1.1em; margin: 0.5em 0; word-wrap: break-word; }
        .node-content p { margin: 0.5em 0; word-wrap: break-word; }
        .node-content ul, .node-content ol { margin-left: 1.5em; }
        .node-content li { word-wrap: break-word; }
        .node-content code { 
            background: #f4f4f4; 
            padding: 2px 6px; 
            border-radius: 3px;
            font-family: monospace;
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: break-word;
        }
        .node-content pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        .node-content pre code {
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        .node-content strong { font-weight: bold; }
        .node-content em { font-style: italic; }

        .edit-mode {
            display: none;
            height: 100%;
        }

        .node.editing .edit-mode {
            display: flex;
            flex-direction: column;
        }

        .node.editing .view-mode {
            display: none;
        }

        .node-textarea {
            width: 100%;
            height: 100%;
            min-height: 100px;
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            resize: none;
            box-sizing: border-box;
        }

        .toolbar {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }

        .toolbar button {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            margin-right: 10px;
        }

        .toolbar button:hover {
            background: #5568d3;
        }

        .info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            font-size: 12px;
            color: #333;
            max-width: 300px;
        }

        .info h3 {
            margin-bottom: 8px;
            color: #667eea;
            font-size: 14px;
        }

        .info ul {
            list-style: none;
            padding: 0;
        }

        .info li {
            margin-bottom: 5px;
            padding-left: 15px;
            position: relative;
        }

        .info li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: #667eea;
        }

        .connection {
            stroke: white;
            stroke-width: 2;
            opacity: 0.8;
            pointer-events: stroke;
            cursor: pointer;
            marker-end: url(#arrowhead);
        }

        .connection:hover {
            stroke-width: 4;
            opacity: 1;
        }

        .context-menu {
            position: fixed;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            min-width: 150px;
            display: none;
        }

        .context-menu.show {
            display: block;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
            color: #333;
            border-bottom: 1px solid #e0e0e0;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: #f0f4ff;
        }

        .context-menu-item:first-child {
            border-radius: 6px 6px 0 0;
        }

        .context-menu-item:last-child {
            border-radius: 0 0 6px 6px;
        }

        .context-menu-item.delete {
            color: #e74c3c;
            font-weight: 500;
        }

        .context-menu-item.delete:hover {
            background: #fee;
        }

        /* „Ç®„ÇØ„Çπ„Éù„Éº„Éà„É°„Éã„É•„Éº */
        .export-menu {
            position: fixed;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            min-width: 180px;
            display: none;
            padding: 10px;
        }

        .export-menu.show {
            display: block;
        }

        .export-menu h4 {
            margin: 0 0 10px 0;
            color: #667eea;
            font-size: 14px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }

        .export-menu button {
            width: 100%;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            margin-bottom: 6px;
            text-align: left;
        }

        .export-menu button:last-child {
            margin-bottom: 0;
        }

        .export-menu button:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button id="addNodeBtn">‚ûï „Éé„Éº„ÉâËøΩÂä†</button>
        <button id="clearBtn">üóëÔ∏è „Åô„Åπ„Å¶„ÇØ„É™„Ç¢</button>
        <button id="exportBtn">üíæ „Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>
    </div>

    <div class="info">
        <h3>üìù Êìç‰ΩúÊñπÊ≥ï</h3>
        <ul>
            <li>„Éé„Éº„Éâ„Çí„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÁßªÂãï</li>
            <li>„Éé„Éº„Éâ„ÅÆ4Ëæ∫„Çí„Éâ„É©„ÉÉ„Ç∞„Åß„É™„Çµ„Ç§„Ç∫</li>
            <li>„ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Á∑®ÈõÜ</li>
            <li>Á®ÆÂà•„ÅßÊ≠£Â∏∏Á≥ª/Áï∞Â∏∏Á≥ª„ÇíÈÅ∏Êäû</li>
            <li>„Çπ„ÉÜ„Éº„Çø„Çπ„Åß„Éé„Éº„Éâ„ÅÆË¶ã„ÅüÁõÆ„ÅåÂ§âÂåñ</li>
            <li>„Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥ÈÉ®ÂàÜ„Çí„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÁ∑®ÈõÜ</li>
            <li>Á∑®ÈõÜ‰∏≠„ÅØÂ§ñÂÅ¥„ÇØ„É™„ÉÉ„ÇØ„ÅßËá™Âãï‰øùÂ≠ò</li>
            <li>„Éé„Éº„Éâ„ÅÆ4ÊñπÂêë„ÅÆÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Êé•Á∂ö</li>
            <li>„Éé„Éº„Éâ„ÇíÂè≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÂâäÈô§</li>
            <li>Êé•Á∂öÁ∑ö„ÇíÂè≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÂâäÈô§</li>
            <li>ËÉåÊôØ„Çí„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÂÖ®‰ΩìÁßªÂãï</li>
        </ul>
    </div>

    <div id="canvas">
        <svg id="svg"></svg>
    </div>

    <div id="contextMenu" class="context-menu">
        <div class="context-menu-item delete" id="deleteNode">üóëÔ∏è „Éé„Éº„Éâ„ÇíÂâäÈô§</div>
        <div class="context-menu-item delete" id="deleteConnection">üóëÔ∏è Êé•Á∂ö„ÇíÂâäÈô§</div>
    </div>

    <div id="exportMenu" class="export-menu">
        <h4>üì• „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂΩ¢Âºè„ÇíÈÅ∏Êäû</h4>
        <button id="exportCsvBtn">üìÑ CSVÂΩ¢Âºè</button>
        <button id="exportJsonBtn">üìã JSONÂΩ¢Âºè</button>
        <button id="exportSvgBtn">üñºÔ∏è SVGÂΩ¢Âºè</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const svg = document.getElementById('svg');
        const addNodeBtn = document.getElementById('addNodeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const exportBtn = document.getElementById('exportBtn');
        const contextMenu = document.getElementById('contextMenu');
        const exportMenu = document.getElementById('exportMenu');
        const deleteNodeBtn = document.getElementById('deleteNode');
        const deleteConnectionBtn = document.getElementById('deleteConnection');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const exportSvgBtn = document.getElementById('exportSvgBtn');

        let nodes = [];
        let connections = [];
        let nodeIdCounter = 0;
        let isDraggingCanvas = false;
        let dragStart = { x: 0, y: 0 };
        let selectedConnection = null;
        let selectedNode = null;
        let connectingFrom = null;

        // UUIDÁîüÊàêÈñ¢Êï∞
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // UNIXÊôÇÈñìÂèñÂæó
        function getUnixTime() {
            return Math.floor(Date.now() / 1000);
        }

        // ‰∏ÄÊÑè„ÅÆ„Éé„Éº„ÉâIDÁîüÊàê
        function generateNodeUniqueId() {
            return `${generateUUID()}_${getUnixTime()}`;
        }

        // „Éé„Éº„Éâ‰ΩúÊàê
        function createNode(x, y, content = '# Êñ∞„Åó„ÅÑ„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ\n\nÂÜÖÂÆπ„ÇíË®òËø∞...') {
            const nodeId = nodeIdCounter++;
            const node = document.createElement('div');
            node.className = 'node';
            node.style.left = x + 'px';
            node.style.top = y + 'px';
            
            node.innerHTML = `
                <div class="resize-handle top"></div>
                <div class="resize-handle bottom"></div>
                <div class="resize-handle left"></div>
                <div class="resize-handle right"></div>
                <div class="connector top" data-direction="top"></div>
                <div class="connector bottom" data-direction="bottom"></div>
                <div class="connector left" data-direction="left"></div>
                <div class="connector right" data-direction="right"></div>
                <div class="node-header">
                    <div class="node-left-section">
                        <select class="test-type type-Ê≠£Â∏∏Á≥ª">
                            <option value="Ê≠£Â∏∏Á≥ª">Ê≠£Â∏∏Á≥ª</option>
                            <option value="Áï∞Â∏∏Á≥ª">Áï∞Â∏∏Á≥ª</option>
                            <option value="„Åù„ÅÆ‰ªñ">„Åù„ÅÆ‰ªñ</option>
                        </select>
                        <select class="node-status status-Ëµ∑Á•®">
                            <option value="Ëµ∑Á•®">Ëµ∑Á•®</option>
                            <option value="OK">OK</option>
                            <option value="NG">NG</option>
                            <option value="Âç¥‰∏ã">Âç¥‰∏ã</option>
                            <option value="‰øùÁïô">‰øùÁïô</option>
                        </select>
                    </div>
                    <div class="node-id-container">
                        <div class="node-id" contenteditable="true">TC-${String(nodeId + 1).padStart(3, '0')}</div>
                    </div>
                </div>
                <div class="view-mode">
                    <div class="node-content"></div>
                </div>
                <div class="edit-mode">
                    <textarea class="node-textarea">${content}</textarea>
                </div>
            `;

            const nodeData = {
                id: nodeId,
                uniqueId: generateNodeUniqueId(),
                element: node,
                x: x,
                y: y,
                width: null,
                height: null,
                content: content,
                testCaseId: `TC-${String(nodeId + 1).padStart(3, '0')}`,
                status: 'Ëµ∑Á•®',
                testType: 'Ê≠£Â∏∏Á≥ª'
            };

            nodes.push(nodeData);
            canvas.appendChild(node);

            // „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥„É¨„É≥„ÉÄ„É™„É≥„Ç∞
            updateNodeContent(nodeData);

            // ÂàùÊúü„Çµ„Ç§„Ç∫„ÇíË®òÈå≤
            setTimeout(() => {
                if (!nodeData.width) {
                    nodeData.width = node.offsetWidth;
                }
                if (!nodeData.height) {
                    nodeData.height = node.offsetHeight;
                }
            }, 0);

            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            setupNodeEvents(nodeData);

            return nodeData;
        }

        // „Éé„Éº„Éâ„Ç≥„É≥„ÉÜ„É≥„ÉÑÊõ¥Êñ∞
        function updateNodeContent(nodeData) {
            const contentDiv = nodeData.element.querySelector('.node-content');
            contentDiv.innerHTML = marked.parse(nodeData.content);
        }

        // „Éé„Éº„Éâ„ÅÆË¶ã„ÅüÁõÆ„ÇíÊõ¥Êñ∞
        function updateNodeAppearance(nodeData) {
            const node = nodeData.element;
            
            // „Çπ„ÉÜ„Éº„Çø„Çπ„Å´„Çà„Çã„Éé„Éº„Éâ„ÇØ„É©„Çπ„ÅÆÊõ¥Êñ∞
            node.classList.remove('status-Ëµ∑Á•®', 'status-OK', 'status-NG', 'status-Âç¥‰∏ã', 'status-‰øùÁïô');
            node.classList.add(`status-${nodeData.status}`);
        }

        // „Éé„Éº„Éâ„Ç§„Éô„É≥„ÉàË®≠ÂÆö
        function setupNodeEvents(nodeData) {
            const node = nodeData.element;
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            // „ÉÜ„Çπ„ÉàÁ®ÆÂà•Â§âÊõ¥
            const testTypeSelect = node.querySelector('.test-type');
            testTypeSelect.addEventListener('change', (e) => {
                nodeData.testType = e.target.value;
                testTypeSelect.className = `test-type type-${e.target.value}`;
            });

            // „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπIDÁ∑®ÈõÜ
            const nodeIdInput = node.querySelector('.node-id');
            nodeIdInput.addEventListener('blur', () => {
                nodeData.testCaseId = nodeIdInput.textContent;
            });

            nodeIdInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    nodeIdInput.blur();
                }
            });

            // „Çπ„ÉÜ„Éº„Çø„ÇπÂ§âÊõ¥
            const statusSelect = node.querySelector('.node-status');
            statusSelect.addEventListener('change', (e) => {
                nodeData.status = e.target.value;
                statusSelect.className = `node-status status-${e.target.value}`;
                updateNodeAppearance(nodeData);
            });

            // „Éâ„É©„ÉÉ„Ç∞ÈñãÂßã
            node.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'BUTTON' || 
                    e.target.tagName === 'TEXTAREA' || 
                    e.target.tagName === 'SELECT' || 
                    e.target.classList.contains('node-id') ||
                    e.target.classList.contains('connector') ||
                    e.target.classList.contains('resize-handle')) return;
                
                isDragging = true;
                node.classList.add('dragging');
                dragOffset.x = e.clientX - nodeData.x;
                dragOffset.y = e.clientY - nodeData.y;
                e.stopPropagation();
            });

            // „Éû„Éº„ÇØ„ÉÄ„Ç¶„É≥ÈÉ®ÂàÜ„ÅÆ„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÁ∑®ÈõÜ„É¢„Éº„Éâ„Å´
            const contentDiv = node.querySelector('.node-content');
            contentDiv.addEventListener('dblclick', () => {
                // ÁèæÂú®„ÅÆ„Éé„Éº„Éâ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó„Åó„Å¶Âõ∫ÂÆö
                const currentWidth = node.offsetWidth;
                const currentHeight = node.offsetHeight;
                
                // „Éé„Éº„Éâ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö
                if (!nodeData.width || nodeData.width < currentWidth) {
                    nodeData.width = currentWidth;
                }
                if (!nodeData.height || nodeData.height < currentHeight) {
                    nodeData.height = currentHeight;
                }
                
                node.style.width = nodeData.width + 'px';
                node.style.height = nodeData.height + 'px';
                
                node.classList.add('editing');
                const textarea = node.querySelector('.node-textarea');
                textarea.focus();
            });

            // „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢Â§ñ„ÇØ„É™„ÉÉ„ÇØ„Åß‰øùÂ≠ò
            const textarea = node.querySelector('.node-textarea');
            document.addEventListener('click', (e) => {
                if (node.classList.contains('editing')) {
                    // „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„Å®„Åù„ÅÆË¶™Ë¶ÅÁ¥†‰ª•Â§ñ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÂ†¥Âêà
                    if (!textarea.contains(e.target) && !node.contains(e.target)) {
                        nodeData.content = textarea.value;
                        updateNodeContent(nodeData);
                        node.classList.remove('editing');
                    } else if (node.contains(e.target) && !textarea.contains(e.target) && e.target.tagName !== 'TEXTAREA') {
                        // „Éé„Éº„ÉâÂÜÖ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢‰ª•Â§ñ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÂ†¥Âêà
                        nodeData.content = textarea.value;
                        updateNodeContent(nodeData);
                        node.classList.remove('editing');
                    }
                }
            });

            // „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´„ÅÆ„Ç§„Éô„É≥„Éà
            const resizeHandles = node.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                let isResizing = false;
                let resizeStartX = 0;
                let resizeStartY = 0;
                let startWidth = 0;
                let startHeight = 0;
                let startX = 0;
                let startY = 0;

                handle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    isResizing = true;
                    resizeStartX = e.clientX;
                    resizeStartY = e.clientY;
                    startWidth = node.offsetWidth;
                    startHeight = node.offsetHeight;
                    startX = nodeData.x;
                    startY = nodeData.y;
                    node.classList.add('resizing');

                    const handleMouseMove = (e) => {
                        if (!isResizing) return;

                        const deltaX = e.clientX - resizeStartX;
                        const deltaY = e.clientY - resizeStartY;

                        if (handle.classList.contains('right')) {
                            const newWidth = Math.max(200, startWidth + deltaX);
                            node.style.width = newWidth + 'px';
                            nodeData.width = newWidth;
                        } else if (handle.classList.contains('left')) {
                            const newWidth = Math.max(200, startWidth - deltaX);
                            if (newWidth > 200) {
                                node.style.width = newWidth + 'px';
                                nodeData.width = newWidth;
                                nodeData.x = startX + deltaX;
                                node.style.left = nodeData.x + 'px';
                            }
                        } else if (handle.classList.contains('bottom')) {
                            const newHeight = Math.max(100, startHeight + deltaY);
                            node.style.height = newHeight + 'px';
                            nodeData.height = newHeight;
                        } else if (handle.classList.contains('top')) {
                            const newHeight = Math.max(100, startHeight - deltaY);
                            if (newHeight > 100) {
                                node.style.height = newHeight + 'px';
                                nodeData.height = newHeight;
                                nodeData.y = startY + deltaY;
                                node.style.top = nodeData.y + 'px';
                            }
                        }

                        updateConnections();
                    };

                    const handleMouseUp = () => {
                        if (isResizing) {
                            isResizing = false;
                            node.classList.remove('resizing');
                            document.removeEventListener('mousemove', handleMouseMove);
                            document.removeEventListener('mouseup', handleMouseUp);
                        }
                    };

                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                });
            });

            // „Éé„Éº„Éâ„ÅÆÂè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº
            node.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                selectedNode = nodeData;
                selectedConnection = null;
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
                contextMenu.classList.add('show');
                
                // „É°„Éã„É•„ÉºÈ†ÖÁõÆ„ÅÆË°®Á§∫/ÈùûË°®Á§∫
                deleteNodeBtn.style.display = 'block';
                deleteConnectionBtn.style.display = 'none';
            });

            // „Ç≥„Éç„ÇØ„Çø„Éº„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
            const connectors = node.querySelectorAll('.connector');
            connectors.forEach(connector => {
                connector.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleConnectorClick(nodeData, connector);
                });
            });

            // „Éû„Ç¶„ÇπÁßªÂãï
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    nodeData.x = e.clientX - dragOffset.x;
                    nodeData.y = e.clientY - dragOffset.y;
                    node.style.left = nodeData.x + 'px';
                    node.style.top = nodeData.y + 'px';
                    updateConnections();
                }
            });

            // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫Ü
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    node.classList.remove('dragging');
                }
            });
        }

        // „Éé„Éº„ÉâÂâäÈô§
        function deleteNode(nodeData) {
            nodeData.element.remove();
            nodes = nodes.filter(n => n.id !== nodeData.id);
            connections = connections.filter(c => c.from !== nodeData.id && c.to !== nodeData.id);
            updateConnections();
        }

        // Êé•Á∂ö‰ΩúÊàê
        function createConnection(fromNodeId, toNodeId, fromDirection, toDirection) {
            connections.push({ 
                from: fromNodeId, 
                to: toNodeId,
                fromDirection: fromDirection || 'center',
                toDirection: toDirection || 'center'
            });
            updateConnections();
        }

        // „Ç≥„Éç„ÇØ„Çø„Éº„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ
        function handleConnectorClick(nodeData, connector) {
            const direction = connector.dataset.direction;
            
            if (!connectingFrom) {
                // Êé•Á∂öÈñãÂßã
                connectingFrom = {
                    node: nodeData,
                    direction: direction,
                    connector: connector
                };
                connector.classList.add('active');
            } else {
                // Êé•Á∂öÂÆå‰∫Ü
                if (connectingFrom.node.id !== nodeData.id) {
                    createConnection(
                        connectingFrom.node.id, 
                        nodeData.id,
                        connectingFrom.direction,
                        direction
                    );
                }
                // „Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖã„ÇíËß£Èô§
                const activeConnectors = document.querySelectorAll('.connector.active');
                activeConnectors.forEach(c => c.classList.remove('active'));
                connectingFrom = null;
            }
        }

        // CSV„Ç®„Çπ„Ç±„Éº„ÉóÈñ¢Êï∞
        function escapeCsv(value) {
            if (value == null) return '""';
            const stringValue = String(value);
            // „ÉÄ„Éñ„É´„ÇØ„Ç©„Éº„ÉÜ„Éº„Ç∑„Éß„É≥„Çí„Ç®„Çπ„Ç±„Éº„ÉóÔºà‰∫åÈáçÂåñÔºâ
            const escaped = stringValue.replace(/"/g, '""');
            // „Ç´„É≥„Éû„ÄÅÊîπË°å„ÄÅ„ÉÄ„Éñ„É´„ÇØ„Ç©„Éº„ÉÜ„Éº„Ç∑„Éß„É≥„ÅåÂê´„Åæ„Çå„ÇãÂ†¥Âêà„ÅØÂºïÁî®Á¨¶„ÅßÂõ≤„ÇÄ
            return `"${escaped}"`;
        }

        // CSVÂΩ¢Âºè„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà
        function exportToCsv() {
            // „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
            const duplicates = checkDuplicateTestCaseIds();
            if (duplicates.length > 0) {
                alert('ÈáçË§á„ÅÆ„ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ‰∏ÄÊÑè„ÅÆÂÄ§„ÇíÁôªÈå≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\nÈáçË§áID: ' + duplicates.join(', '));
                return;
            }

            // „Éò„ÉÉ„ÉÄ„ÉºË°åÔºàËã±Ë™ûÔºâ
            const headers = [
                'unique_id',
                'test_case_id',
                'test_type',
                'status',
                'markdown_content',
                'height',
                'width',
                'x_position',
                'y_position',
                'connected_node_ids'
            ];

            let csvContent = headers.map(h => escapeCsv(h)).join(',') + '\n';

            // „Éá„Éº„ÇøË°å
            nodes.forEach(node => {
                // Êé•Á∂öÂÖà„ÅÆ„Éé„Éº„ÉâID„É™„Çπ„Éà„ÇíÂèñÂæóÔºàÊñπÂêëÊÉÖÂ†±‰ªò„ÅçÔºâ
                const connectedToNodeIds = connections
                    .filter(conn => conn.from === node.id)
                    .map(conn => {
                        const targetNode = nodes.find(n => n.id === conn.to);
                        return targetNode ? {
                            direction: 'to',
                            node_id: targetNode.uniqueId
                        } : null;
                    })
                    .filter(conn => conn !== null);

                // Êé•Á∂öÂÖÉ„ÅÆ„Éé„Éº„ÉâID„É™„Çπ„Éà„ÇÇÂèñÂæó
                const connectedFromNodeIds = connections
                    .filter(conn => conn.to === node.id)
                    .map(conn => {
                        const sourceNode = nodes.find(n => n.id === conn.from);
                        return sourceNode ? {
                            direction: 'from',
                            node_id: sourceNode.uniqueId
                        } : null;
                    })
                    .filter(conn => conn !== null);

                // ‰∏°Êñπ„ÇíÁµêÂêà„Åó„Å¶JSONÊñáÂ≠óÂàóÂåñ
                const allConnections = [...connectedToNodeIds, ...connectedFromNodeIds];
                const connectionsJson = JSON.stringify(allConnections);

                const row = [
                    node.uniqueId,
                    node.testCaseId.trim(),
                    node.testType,
                    node.status,
                    node.content,
                    node.height || node.element.offsetHeight,
                    node.width || node.element.offsetWidth,
                    node.x,
                    node.y,
                    connectionsJson
                ];

                csvContent += row.map(value => escapeCsv(value)).join(',') + '\n';
            });

            // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.setAttribute('href', url);
            link.setAttribute('download', `test_mindmap_${timestamp}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // JSONÂΩ¢Âºè„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà
        function exportToJson() {
            // „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
            const duplicates = checkDuplicateTestCaseIds();
            if (duplicates.length > 0) {
                alert('ÈáçË§á„ÅÆ„ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ‰∏ÄÊÑè„ÅÆÂÄ§„ÇíÁôªÈå≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\nÈáçË§áID: ' + duplicates.join(', '));
                return;
            }

            const exportData = {
                export_date: new Date().toISOString(),
                version: '1.0',
                nodes: nodes.map(node => {
                    // Êé•Á∂öÂÖà„ÅÆ„Éé„Éº„ÉâID„É™„Çπ„Éà„ÇíÂèñÂæóÔºàÊñπÂêëÊÉÖÂ†±‰ªò„ÅçÔºâ
                    const connectedToNodeIds = connections
                        .filter(conn => conn.from === node.id)
                        .map(conn => {
                            const targetNode = nodes.find(n => n.id === conn.to);
                            return targetNode ? {
                                direction: 'to',
                                node_id: targetNode.uniqueId
                            } : null;
                        })
                        .filter(conn => conn !== null);

                    // Êé•Á∂öÂÖÉ„ÅÆ„Éé„Éº„ÉâID„É™„Çπ„Éà„ÇÇÂèñÂæó
                    const connectedFromNodeIds = connections
                        .filter(conn => conn.to === node.id)
                        .map(conn => {
                            const sourceNode = nodes.find(n => n.id === conn.from);
                            return sourceNode ? {
                                direction: 'from',
                                node_id: sourceNode.uniqueId
                            } : null;
                        })
                        .filter(conn => conn !== null);

                    // ‰∏°Êñπ„ÇíÁµêÂêà
                    const allConnections = [...connectedToNodeIds, ...connectedFromNodeIds];

                    return {
                        unique_id: node.uniqueId,
                        test_case_id: node.testCaseId.trim(),
                        test_type: node.testType,
                        status: node.status,
                        markdown_content: node.content,
                        height: node.height || node.element.offsetHeight,
                        width: node.width || node.element.offsetWidth,
                        x_position: node.x,
                        y_position: node.y,
                        connected_node_ids: allConnections
                    };
                })
            };

            // JSONÊñáÂ≠óÂàó„Å´Â§âÊèõÔºàÊï¥ÂΩ¢„ÅÇ„ÇäÔºâ
            const jsonContent = JSON.stringify(exportData, null, 2);

            // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.setAttribute('href', url);
            link.setAttribute('download', `test_mindmap_${timestamp}.json`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // SVGÂΩ¢Âºè„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà
        function exportToSvg() {
            // „Ç≠„É£„É≥„Éê„Çπ„ÅÆÂ¢ÉÁïå„ÇíË®àÁÆó
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            nodes.forEach(node => {
                const rect = node.element.getBoundingClientRect();
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + rect.width);
                maxY = Math.max(maxY, node.y + rect.height);
            });

            const padding = 50;
            const viewBoxX = minX - padding;
            const viewBoxY = minY - padding;
            const viewBoxWidth = maxX - minX + padding * 2;
            const viewBoxHeight = maxY - minY + padding * 2;

            // SVGË¶ÅÁ¥†„ÅÆ‰ΩúÊàê
            let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}" width="${viewBoxWidth}" height="${viewBoxHeight}">
  <defs>
    <style>
      .node-rect { fill: white; stroke: #667eea; stroke-width: 3; }
      .node-rect-ok { stroke: #2ecc71; }
      .node-rect-ng { stroke: #e74c3c; }
      .node-rect-rejected { fill: #e0e0e0; }
      .node-rect-pending { fill: #e6d5f5; }
      .connection-line { stroke: white; stroke-width: 2; opacity: 0.8; }
      .node-text { font-family: 'Segoe UI', sans-serif; font-size: 14px; fill: #333; }
      .node-id-text { font-weight: bold; fill: #667eea; font-size: 14px; }
      .test-type-normal { fill: #2ecc71; }
      .test-type-abnormal { fill: #e74c3c; }
      .test-type-other { fill: #95a5a6; }
    </style>
  </defs>
  
  <!-- Êé•Á∂öÁ∑ö -->
  <g id="connections">
`;

            // Êé•Á∂öÁ∑ö„ÇíÊèèÁîª
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                
                if (fromNode && toNode) {
                    const fromRect = fromNode.element.getBoundingClientRect();
                    const toRect = toNode.element.getBoundingClientRect();
                    
                    const fromX = fromNode.x + fromRect.width / 2;
                    const fromY = fromNode.y + fromRect.height / 2;
                    const toX = toNode.x + toRect.width / 2;
                    const toY = toNode.y + toRect.height / 2;
                    
                    svgContent += `    <line x1="${fromX}" y1="${fromY}" x2="${toX}" y2="${toY}" class="connection-line"/>\n`;
                }
            });

            svgContent += `  </g>
  
  <!-- „Éé„Éº„Éâ -->
  <g id="nodes">
`;

            // „Éé„Éº„Éâ„ÇíÊèèÁîª
            nodes.forEach(node => {
                const rect = node.element.getBoundingClientRect();
                const width = node.width || rect.width;
                const height = node.height || rect.height;
                
                let nodeClass = 'node-rect';
                if (node.status === 'OK') nodeClass += ' node-rect-ok';
                else if (node.status === 'NG') nodeClass += ' node-rect-ng';
                else if (node.status === 'Âç¥‰∏ã') nodeClass += ' node-rect-rejected';
                else if (node.status === '‰øùÁïô') nodeClass += ' node-rect-pending';

                let typeClass = 'test-type-other';
                if (node.testType === 'Ê≠£Â∏∏Á≥ª') typeClass = 'test-type-normal';
                else if (node.testType === 'Áï∞Â∏∏Á≥ª') typeClass = 'test-type-abnormal';

                svgContent += `    <g id="node-${node.uniqueId}">
      <rect x="${node.x}" y="${node.y}" width="${width}" height="${height}" rx="12" class="${nodeClass}"/>
      
      <!-- „ÉÜ„Çπ„ÉàÁ®ÆÂà• -->
      <rect x="${node.x + 10}" y="${node.y + 10}" width="60" height="20" rx="4" class="${typeClass}"/>
      <text x="${node.x + 40}" y="${node.y + 24}" text-anchor="middle" class="node-text" fill="white" font-size="11">${node.testType}</text>
      
      <!-- „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID -->
      <text x="${node.x + 80}" y="${node.y + 24}" class="node-id-text">${escapeXml(node.testCaseId)}</text>
      
      <!-- „Çπ„ÉÜ„Éº„Çø„Çπ -->
      <text x="${node.x + width - 10}" y="${node.y + 24}" text-anchor="end" class="node-text" font-size="12">${escapeXml(node.status)}</text>
      
      <!-- „Ç≥„É≥„ÉÜ„É≥„ÉÑÔºàÁ∞°Áï•ÁâàÔºâ -->
      <text x="${node.x + 15}" y="${node.y + 45}" class="node-text">
        ${escapeXml(node.content.substring(0, 50) + (node.content.length > 50 ? '...' : ''))}
      </text>
    </g>
`;
            });

            svgContent += `  </g>
</svg>`;

            // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.setAttribute('href', url);
            link.setAttribute('download', `test_mindmap_${timestamp}.svg`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // XMLÁâπÊÆäÊñáÂ≠ó„ÅÆ„Ç®„Çπ„Ç±„Éº„Éó
        function escapeXml(text) {
            if (!text) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        // „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπID„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
        function checkDuplicateTestCaseIds() {
            const testCaseIds = nodes.map(node => node.testCaseId.trim());
            const uniqueIds = new Set();
            const duplicates = [];

            testCaseIds.forEach(id => {
                if (uniqueIds.has(id)) {
                    if (!duplicates.includes(id)) {
                        duplicates.push(id);
                    }
                } else {
                    uniqueIds.add(id);
                }
            });

            return duplicates;
        }

        // Êé•Á∂öÊõ¥Êñ∞
        function updateConnections() {
            svg.innerHTML = '<defs><marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto"><polygon points="0 0, 10 3, 0 6" fill="white" /></marker></defs>';
            
            connections.forEach((conn, index) => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                
                if (fromNode && toNode) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    
                    // „Ç≥„Éç„ÇØ„Çø„Éº„ÅÆ‰ΩçÁΩÆ„ÇíË®àÁÆó
                    const fromPos = getConnectorPosition(fromNode, conn.fromDirection || 'center');
                    const toPos = getConnectorPosition(toNode, conn.toDirection || 'center');
                    
                    line.setAttribute('x1', fromPos.x);
                    line.setAttribute('y1', fromPos.y);
                    line.setAttribute('x2', toPos.x);
                    line.setAttribute('y2', toPos.y);
                    line.classList.add('connection');
                    line.dataset.connectionIndex = index;
                    
                    // Âè≥„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
                    line.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        selectedConnection = index;
                        selectedNode = null;
                        contextMenu.style.left = e.clientX + 'px';
                        contextMenu.style.top = e.clientY + 'px';
                        contextMenu.classList.add('show');
                        
                        // „É°„Éã„É•„ÉºÈ†ÖÁõÆ„ÅÆË°®Á§∫/ÈùûË°®Á§∫
                        deleteNodeBtn.style.display = 'none';
                        deleteConnectionBtn.style.display = 'block';
                    });
                    
                    svg.appendChild(line);
                }
            });
        }

        // „Ç≥„Éç„ÇØ„Çø„Éº„ÅÆ‰ΩçÁΩÆ„ÇíÂèñÂæó
        function getConnectorPosition(nodeData, direction) {
            const rect = nodeData.element.getBoundingClientRect();
            const nodeWidth = nodeData.width || rect.width;
            const nodeHeight = nodeData.height || rect.height;
            
            let x, y;
            
            switch(direction) {
                case 'top':
                    x = nodeData.x + nodeWidth / 2;
                    y = nodeData.y;
                    break;
                case 'bottom':
                    x = nodeData.x + nodeWidth / 2;
                    y = nodeData.y + nodeHeight;
                    break;
                case 'left':
                    x = nodeData.x;
                    y = nodeData.y + nodeHeight / 2;
                    break;
                case 'right':
                    x = nodeData.x + nodeWidth;
                    y = nodeData.y + nodeHeight / 2;
                    break;
                default: // center
                    x = nodeData.x + nodeWidth / 2;
                    y = nodeData.y + nodeHeight / 2;
                    break;
            }
            
            return { x, y };
        }

        // „ÉÑ„Éº„É´„Éê„Éº„Ç§„Éô„É≥„Éà
        addNodeBtn.addEventListener('click', () => {
            createNode(Math.random() * 600 + 100, Math.random() * 400 + 100);
        });

        exportBtn.addEventListener('click', (e) => {
            const rect = exportBtn.getBoundingClientRect();
            exportMenu.style.left = rect.left + 'px';
            exportMenu.style.top = (rect.bottom + 5) + 'px';
            exportMenu.classList.add('show');
        });

        exportCsvBtn.addEventListener('click', () => {
            exportToCsv();
            exportMenu.classList.remove('show');
        });

        exportJsonBtn.addEventListener('click', () => {
            exportToJson();
            exportMenu.classList.remove('show');
        });

        exportSvgBtn.addEventListener('click', () => {
            exportToSvg();
            exportMenu.classList.remove('show');
        });

        clearBtn.addEventListener('click', () => {
            if (confirm('Êú¨ÂΩì„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                nodes.forEach(n => n.element.remove());
                nodes = [];
                connections = [];
                updateConnections();
            }
        });

        // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„ÅÆ„Éé„Éº„ÉâÂâäÈô§
        deleteNodeBtn.addEventListener('click', () => {
            if (selectedNode !== null) {
                if (confirm('Êú¨ÂΩì„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                    deleteNode(selectedNode);
                    contextMenu.classList.remove('show');
                    selectedNode = null;
                }
            }
        });

        // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„ÅÆÊé•Á∂öÂâäÈô§
        deleteConnectionBtn.addEventListener('click', () => {
            if (selectedConnection !== null) {
                connections.splice(selectedConnection, 1);
                updateConnections();
                contextMenu.classList.remove('show');
                selectedConnection = null;
            }
        });

        // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„ÇíÈñâ„Åò„Çã
        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.classList.remove('show');
            }
            if (!exportMenu.contains(e.target) && !exportBtn.contains(e.target)) {
                exportMenu.classList.remove('show');
            }
        });

        // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãÊôÇ„Å´„Çπ„ÇØ„É≠„Éº„É´„ÇÑ„É™„Çµ„Ç§„Ç∫„ÅßÈñâ„Åò„Çã
        window.addEventListener('scroll', () => {
            contextMenu.classList.remove('show');
            exportMenu.classList.remove('show');
        });

        window.addEventListener('resize', () => {
            contextMenu.classList.remove('show');
            exportMenu.classList.remove('show');
        });

        // „Ç≠„É£„É≥„Éê„Çπ„Éâ„É©„ÉÉ„Ç∞
        canvas.addEventListener('mousedown', (e) => {
            if (e.target === canvas || e.target === svg) {
                isDraggingCanvas = true;
                canvas.classList.add('grabbing');
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingCanvas) {
                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;
                
                nodes.forEach(nodeData => {
                    nodeData.x += dx;
                    nodeData.y += dy;
                    nodeData.element.style.left = nodeData.x + 'px';
                    nodeData.element.style.top = nodeData.y + 'px';
                });
                
                updateConnections();
                dragStart.x = e.clientX;
                dragStart.y = e.clientY;
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingCanvas = false;
            canvas.classList.remove('grabbing');
        });

        // ÂàùÊúü„Éé„Éº„Éâ‰ΩúÊàêÔºà„Éá„É¢Áî®Ôºâ
        const node1 = createNode(200, 150, '# „É≠„Ç∞„Ç§„É≥Ê©üËÉΩ„ÉÜ„Çπ„Éà\n\n## ÂâçÊèêÊù°‰ª∂\n- „É¶„Éº„Ç∂„Éº„ÅåÁôªÈå≤Ê∏à„Åø\n- „É≠„Ç∞„Ç§„É≥ÁîªÈù¢„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Çã\n\n## „ÉÜ„Çπ„ÉàÊâãÈ†Ü\n1. „É¶„Éº„Ç∂„ÉºID„ÇíÂÖ•Âäõ\n2. „Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ\n3. „É≠„Ç∞„Ç§„É≥„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ\n\n## ÊúüÂæÖÁµêÊûú\n„Éõ„Éº„É†ÁîªÈù¢„ÅåË°®Á§∫„Åï„Çå„Çã');
        const node2 = createNode(550, 100, '# Ê≠£Â∏∏Á≥ª„ÉÜ„Çπ„Éà\n\n## ÊâãÈ†Ü\n- ÊúâÂäπ„Å™ID/PW„ÇíÂÖ•Âäõ\n\n## ÁµêÊûú\n**ÊàêÂäü**„Åó„Å¶„É≠„Ç∞„Ç§„É≥„Åß„Åç„Çã');
        const node3 = createNode(550, 300, '# Áï∞Â∏∏Á≥ª„ÉÜ„Çπ„Éà\n\n## ÊâãÈ†Ü\n- ÁÑ°Âäπ„Å™PW„ÇíÂÖ•Âäõ\n\n## ÁµêÊûú\n`„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏`„ÅåË°®Á§∫„Åï„Çå„Çã');
        
        // ÂàùÊúü„Éé„Éº„Éâ„ÅÆ„ÉÜ„Çπ„ÉàÁ®ÆÂà•„ÇíË®≠ÂÆö
        node2.testType = 'Ê≠£Â∏∏Á≥ª';
        node2.element.querySelector('.test-type').value = 'Ê≠£Â∏∏Á≥ª';
        node2.element.querySelector('.test-type').className = 'test-type type-Ê≠£Â∏∏Á≥ª';
        
        node3.testType = 'Áï∞Â∏∏Á≥ª';
        node3.element.querySelector('.test-type').value = 'Áï∞Â∏∏Á≥ª';
        node3.element.querySelector('.test-type').className = 'test-type type-Áï∞Â∏∏Á≥ª';
        
        createConnection(node1.id, node2.id, 'right', 'left');
        createConnection(node1.id, node3.id, 'right', 'left');
    </script>
</body>
</html>